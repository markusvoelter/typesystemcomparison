\section{Conclusion and Related Work}
\label{sec:conclusion}

\newcommand{\xtypes}{XTypeS}
\newcommand{\xtext}{Xtext}

A typical way of declaring constraints in metamodels is to use OCL (Object
Constraint Language) \cite{WarmerKleppe99,OCLOMG}.  OCL is an expression
language, while our \xtypes{} is based on type system rules; furthermore, while
OCL is suitable for specifying constraints, it might be hard to use to perform
type inference.

There are other tools for implementing DSLs and their text editors with IDE
functionalities (we also refer to \cite{PP08} for a comparison). Tools like IMP
(The IDE Meta-Tooling Platform) \cite{imp09} and DLTK (Dynamic Languages
Toolkit) \cite{DLTK} only deal with IDE functionalities. TCS (Textual Concrete
Syntax) \cite{tcs} is similar to \xtext, but with the latter it is easier to
describe the abstract and concrete syntax at once, and it is completely open to
customization of every part of the generated IDE (besides, TCS seems to be no
longer under active development). EMFText~\cite{emftext09}, instead of deriving
a metamodel from the grammar, does the opposite, i.e., the language to be
implemented must be defined in an abstract way using an EMF metamodel. Since
also EMFText relies on EMF we believe that \xtypes{} could also be used with
this tool, though we still have not investigated this issue.
Spoofax~\cite{Spoofax2010}, another language workbench which targets Eclipse,
fosters agile language design and development (e.g., changes to the language can
be dynamically loaded into the environment); it does not require Java code for
the analysis of a program (and other IDE related mechanisms) since it relies on
Stratego~\cite{Stratego2008} for rule-based specifications.  With this respect,
\xtypes{} tries to fill the gap concerning the typing of programs, which in
\xtext{} which still requires Java programming, with a type system DSL.

EriLex~\cite{EriLex} is a software tool for generating support code for embedded
domain specific languages and it supports specifying syntax, type rules, and
dynamic semantics of such languages but it does not generate any artifact for
IDE functionalities. MPS (Meta Programming System) \cite{MPS} is another tool
for developing a DSL, and it also provides IDE functionalities, but it does not
target Eclipse and its well-known functionalities.

There are older works that aim at providing complete frameworks for language
implementation (both compilation and editing environment), such as
\emph{Synthesizer}~\cite{Synthesizer} and \emph{Centaur}~\cite{Centaur} (the
former relying on its own specification language and the latter relying on Lisp,
Prolog and other formalisms \cite{Metal,PPML,Typol}). \xtext{} shares with
these tools the philosophy that the editing part is crucial for the programming
(in particular the immediate feedback about problems in the program being
editing~\cite{Synthesizer}) and thus a framework for implementing languages
should address also this functionality.  \xtext, and then \xtypes, aim at
providing these functionalities on top of the widely used Eclipse platform and
by relying on EMF which is a very useful framework for modeling and manipulation
of models (in this case the AST of the programs).

Although \xtypes{} was designed and developed to be used in a language
implemented in \xtext, rules written in \xtypes{} do not refer to the syntax of
the language elements, but only to the structure of the model representing the
AST.  Differently from other approaches, such as, e.g.,
\cite{Centaur,MPS,ASFSDF,Ruler,PLTRedex,EriLex,Neverlang2010}, which require the
programmer to use the framework also for defining the syntax of the language, a
type system written in \xtypes{} only needs an EMF metamodel, i.e., the
\emph{ecore} file (in our context, it is the one generated by \xtext). Thus, the
Java code generated by \xtypes{} might also be used to validate any EMF model,
independently from \xtext{} itself.  Indeed, it might be used with any other
frameworks that represent a program in the shape of an EMF model (though in that
case, Java code generation might have to be adapted).

Neverlang \cite{Neverlang2010} is based on the fact that programming language
features can be easily plugged and unplugged. Similarly, \cite{JastAdd} supports
modular specifications of extensible compiler tools and languages.
Spoofax~\cite{Spoofax2010} provides support for language extensions and
embeddings. \xtext{} provides mechanisms for reusing and composing grammars (we
refer to \xtext{} documentation~\cite{xtext}), but at the moment these
mechanisms may require some manual programming w.r.t.\ the automatic
mechanisms of the above mentioned works. However, from the type system point of
view, since \xtypes{} is only connected to the EMF metamodel (and not to the
grammar), we think that it can be used for modular implementation of type system
related functionalities and in particular for implementing \emph{pluggable type
systems}~\cite{Brac04a}.

\xtypes{} does not aim at providing mechanisms for formal proofs for the
language and the type system; for instance, it does not produce, like other
frameworks do (see, e.g., \cite{Ott}), versions of the type system for proof
assistants like Coq~\cite{Coq}, HOL~\cite{HOL} or Isabelle~\cite{Isabelle}.
Although this issue still needs further investigation, we think that
specifications of rules in \xtypes{} might be good candidates for such generated
definitions for proof assistants.

Finally, we just mention here other tools and frameworks for implementation of
DSLs that are different from \xtext{} and \xtypes{} basically for the main goal
and programming context, such as, e.g., \cite{JST98,MetaBorg06,MontiCore10}
which are based on language specification preprocessors,
\cite{XMF08,LanguageBoxes09} which target host language extensions and internal
DSLs, \cite{ASFSDF,Ruler,PLTRedex} which do not target IDE functionalities. We
would also like to stress that, since \xtypes{} is implemented in \xtext{}
itself, it also provides a full feature Eclipse-based editor for writing the
type system with all the standard IDE functionalities, which is something that
the mentioned related works do not provide.
