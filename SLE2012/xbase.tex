\section{Xbase}
\label{sec:xbase}

To leverage type checking and scoping of Xbase in this scenario, the
\emph{Expression} rule in the grammar is replaced with the Xbase
\emph{XExpression} and \emph{JvmTypes} are inferred for \emph{Entities} and
\emph{Forms}.
The validator in the Xbase scenario, written in Xtend, is shown in
Listing~\ref{lst:xbase-validator}. The validation methods (e.g. the one for a
\emph{TextWidget}) look similar to the plain Xtext scenario, with the difference
that now \emph{JvmTypes} are compared, which are supplied by a type provider
which delegates to the built-in Xbase type provider.

%\lstinputlisting[language=xtend,label=lst:xbase-validator,caption=Xtext
%validator in the Xbase scenario.]	{code/XGuiDslJavaValidatorx.xtend}

\begin{lstlisting}[language=xtend,float=tb,label=lst:xbase-validator,caption=Xtext
validator in the Xbase scenario.] 
class XGuiDslJavaValidatorx extends XbaseJavaValidator {
	@Inject private extension GuiTypeProvider typeProvider;

	@Check
	def void checkTextWidgetForNonBoolean(TextWidget widget) {
		val jvmTypeReference = widget.attr.getJvmType
		if (jvmTypeReference == null) return;
		if (jvmTypeReference.getQualifiedName().equals(Boolean::TYPE.getName()))
			error("Textbox may NOT refer to boolean attributes.",
					XGuiDslPackage$Literals::WIDGET__ATTR, IssueCodes::INCOMPATIBLE_TYPES);
	}
}
\end{lstlisting}

The specification of how to infer Java types from the DSL is shown in the
\emph{JvmModelInferrer} in Listing~\ref{lst:xbase-jvm-inferrer}.  For each
entity, a Java class is inferred with fields, getters and setters.
If an initialization expression for an attribute is given it will become the
body of the getter Java method.  To get scoping and type checking of the
\emph{validate} clause inside a \emph{Form} from Xbase, a method with return type \emph{boolean} is inferred for
each validate clause. The method's name is derived from the attribute's name the
widget refers to. The case study requires that the keyword \verb|widgetcontent|
in the \emph{validate} clause must refer to the attribute the widget refers to.
This is done in Xbase by adding a parameter with the same name of the
attribute's type. 
% Though not required in the case study, the entity's attributes
% are also on the scope by adding a parameter of the entity's type. The parameter
% name \emph{it} has a special meaning in Xtend - it may be omitted in an
% expression, so that in a \emph{validate} clause, one could either write
% \lstinline[basicstyle=\ttfamily]{it.name.length > 2} or \verb|name.length > 2|.

%\lstinputlisting[language=xtend,label=lst:xbase-jvm-inferrer,caption=JvmModelInferrer
% written in Xtend.]	{code/XGuiDslJvmModelInferrer.xtend}

\begin{lstlisting}[language=xtend,float=tb,label=lst:xbase-jvm-inferrer,caption=JvmModelInferrer
written in Xtend.] 
class XGuiDslJvmModelInferrer extends AbstractModelInferrer {
	@Inject extension JvmTypesBuilder
	@Inject extension IQualifiedNameProvider
	@Inject extension GuiTypeProvider guiTypeProvider

	def dispatch void infer(Entity element, IJvmDeclaredTypeAcceptor acceptor, boolean preIndexingPhase) {
		acceptor.accept(element.toClass(element.fullyQualifiedName)).initializeLater [
			if (element.superType != null)
				superTypes += element.superType.cloneWithProxies
			for (attribute : element.attributes) {
				val getter = attribute.toGetter(attribute.name, attribute.getJvmType)
				members += getter
				if (attribute.expr != null) {
					getter.body = attribute.expr
				} else  {
					members += attribute.toField(attribute.name, attribute.getJvmType)
					members += attribute.toSetter(attribute.name, attribute.getJvmType)
				}
			}
		]
	}
	def dispatch void infer(Form form, IJvmDeclaredTypeAcceptor acceptor, boolean preIndexingPhase) { 
		acceptor.accept(form.toClass(form.fullyQualifiedName)).initializeLater [
			for (widget: form.widgets) {
		    	if (widget.validate != null && widget.attr != null) {
		    		members += widget.toMethod('validate'+widget.attr.name.toFirstUpper, form.newTypeRef(Boolean::TYPE)) [
		    			parameters += widget.toParameter("widgetcontent", widget.attr.getJvmType)
		    			body = widget.validate
		    		]
		    	}
		    }   		 	
   		]
   	}
}
\end{lstlisting}

% \subsection{Summary}
% The Xbase approach uses the \emph{JvmModelInferrer} to infer and generate Java
% classes with appropriate operations for entities and forms so that it can make
% use of Xbase for scoping and validation (e.g. for the \emph{validate} clause of
% a widget). Types are inferred using the built-in Xbase type provider, for
% example in the validator.
