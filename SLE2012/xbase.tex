\section{Xbase}
\label{sec:xbase}

To leverage type checking and scoping of Xbase in this scenario, the
\emph{Expression} rule in the grammar is replaced with the Xbase
\emph{XExpression} and \emph{JvmTypes} are inferred for \emph{Entities} and
\emph{Forms}.

The validator in the Xbase scenario is shown in listing
\ref{lst:xbase-jvm-inferrer}. The validation methods (e.g. the one for a
\emph{TextWidget}) look similar to the plain Xtext scenario, with the difference
that now \emph{JvmTypes} are compared, which are supplied by a type provider
which delegates to the built-in Xbase type provider.

%\lstinputlisting[language=xtend,label=lst:xbase-validator,caption=Xtext
%validator in the Xbase scenario.]	{code/XGuiDslJavaValidatorx.xtend}

\begin{lstlisting}[language=xtend,float=tb,label=lst:xbase-validator,caption=Xtext
validator in the Xbase scenario.] 
class XGuiDslJavaValidatorx extends XbaseJavaValidator {
	@Inject private extension GuiTypeProvider typeProvider;
	@Inject TypeConformanceComputer typeConformanceComputer;

	@Check
	def void checkTextWidgetForNonBoolean(TextWidget widget) {
		val jvmTypeReference = widget.attr.getJvmType
		if (jvmTypeReference == null) return;
		if (jvmTypeReference.getQualifiedName().equals(Boolean::TYPE.getName())) {
			error("Textbox may NOT refer to boolean attributes.",
					XGuiDslPackage$Literals::WIDGET__ATTR, IssueCodes::INCOMPATIBLE_TYPES);
		}
	}
}
\end{lstlisting}

\subsection{Java Type Inference}
The specification of how to infer Java types from the DSL is shown in the
\emph{JvmModelInferrer} in listing \ref{lst:xbase-jvm-inferrer}.  For each
entity, a Java class is inferred with fields, getters and setters. If an
expression for an attribute is given, it is interpreted as a derived attribute,
so only a getter method is inferred.

% Two Xtend syntax shortcuts are used in this class: The extension syntax with the
% dot after the first argument of an operation (\verb|attribute.toField(...)|
% instead of \verb|toField(attribute, ...)|), and the closure (\verb|[...]|) after
% the parenthesis, if it is the last argument of an operation
% (\lstinline[basicstyle=\ttfamily]{toMethod(...) [...]} instead of
% \lstinline[basicstyle=\ttfamily]{toMethod(..., [...])}.

To get scoping and type checking of the \emph{validate} clause inside a
\emph{Form} from Xbase, a method with return type \emph{boolean} is inferred for
each validate clause. The method's name is derived from the attribute's name the
widget refers to. The case study requires that the keyword \verb|widgetcontent|
in the \emph{validate} clause must refer to the attribute the widget refers to.
This is done in Xbase by adding a parameter with the same name of the
attribute's type. Though not required in the case study, the entity's attributes
are also on the scope by adding a parameter of the entity's type. The parameter
name \emph{it} has a special meaning in Xtend - it may be omitted in an
expression, so that in a \emph{validate} clause, one could either write
\lstinline[basicstyle=\ttfamily]{it.name.length > 2} or \verb|name.length > 2|.

%\lstinputlisting[language=xtend,label=lst:xbase-jvm-inferrer,caption=JvmModelInferrer
% written in Xtend.]	{code/XGuiDslJvmModelInferrer.xtend}

\begin{lstlisting}[language=xtend,float=tb,label=lst:xbase-jvm-inferrer,caption=JvmModelInferrer
written in Xtend.] 
class XGuiDslJvmModelInferrer extends AbstractModelInferrer {
	@Inject extension JvmTypesBuilder
	@Inject extension IQualifiedNameProvider
	@Inject extension GuiTypeProvider guiTypeProvider

	def dispatch void infer(Entity element, IJvmDeclaredTypeAcceptor acceptor, boolean preIndexingPhase) {
		acceptor.accept(element.toClass(element.fullyQualifiedName)).initializeLater [
			documentation = element.documentation
			if (element.superType != null)
				superTypes += element.superType.cloneWithProxies
		    for (attribute : element.attributes) {
					val getter = attribute.toGetter(attribute.name, attribute.getJvmType)
					members += getter
		    	if (attribute.expr != null) {
					getter.body = attribute.expr
		        } else  {
		            members += attribute.toField(attribute.name, attribute.getJvmType)
			        members += attribute.toSetter(attribute.name, attribute.getJvmType)
		        }
		    }
   		]
   	}

	def dispatch void infer(Form form, IJvmDeclaredTypeAcceptor acceptor, boolean preIndexingPhase) { 
		acceptor.accept(form.toClass(form.fullyQualifiedName)).initializeLater [
			documentation = form.documentation 
			for (widget: form.widgets) {
		    	if (widget.validate != null && widget.attr != null) {
		    		members += widget.toMethod('validate'+widget.attr.name.toFirstUpper, form.newTypeRef(Boolean::TYPE)) [
		    			parameters += widget.toParameter("it", form.entity.getJvmType)
		    			parameters += widget.toParameter("widgetcontent", widget.attr.getJvmType)
		    			body = widget.validate
		    		]
		    	}
		    }   		 	
   		]
   	}
}
\end{lstlisting}

% \subsection{Summary}
% The Xbase approach uses the \emph{JvmModelInferrer} to infer and generate Java
% classes with appropriate operations for entities and forms so that it can make
% use of Xbase for scoping and validation (e.g. for the \emph{validate} clause of
% a widget). Types are inferred using the built-in Xbase type provider, for
% example in the validator.
