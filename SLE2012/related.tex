\section{Related Work}
\label{sec:related}

In this Section we overview some related work
concerning Xtext (we also refer to \cite{PP08} for a wider comparison)
and other language frameworks dealing with type system implementations.

\newcommand{\xtypes}{XTypeS}
\newcommand{\xtext}{Xtext}

Tools like IMP (The IDE Meta-Tooling Platform) \cite{imp09} and DLTK (Dynamic
Languages Toolkit) \cite{DLTK} only deal with IDE functionalities and do not
address type system definition specifically. 
The same is true for TCS (Textual Concrete Syntax) \cite{tcs}  
and EMFText~\cite{emftext09}. However, both rely on a meta model (abstract
syntax) expressed using EMF Ecore, so the XTS and XSemantics type system
frameworks discussed in this paper could be used with EMFText and TCS. 
This does not hold for MPS \cite{MPS} and Spoofax~\cite{Spoofax2010}
since they do not rely on EMF Ecore. However, they both come with their own
support for type system specification.

In MPS, language developers specify declarative type system equations with a
special DSL. A solver then tries to solve all the type system equations relevant
to a given program in order to compute types for program elements and to check
the consistency of types. The following is the type equation for a local
variable declaration of the form \ic{int x = 3;}:

\begin{lstlisting}[language=MPS]
typeof(lvd.init) :<=: typeof(lvd.dtype);
\end{lstlisting}

\noindent
It expresses that the type of the \ic{init} expression (the \ic{3} in the
example) must be the same or a subtype of the type of the \ic{dtype} property
(\ic{int} in the example). The following code shows the type calculation of an
array initialization expression (as in \ic{\{1, 2, 3.5\}}). The second line
computes the type \ic{T} as the common supertype of all the types of the
elements in the initialization expression (\ic{float} in the example). The third
line then makes the type of the complete \ic{arrInitExpr} an array of \ic{T}.

\begin{lstlisting}[language=MPS]
type var T
foreach ( e: init.elements ) T :<=: typeof(e)
typeof(arrInitExpr) :==: new ArrayType(T);
\end{lstlisting}

% As a consequence of the declarative nature of MPS' type system specification,
% type systems are easily extensible by adding new rules for new program elements.
% Since MPS focusses on language extension and embedding, it is crucial that type
% systems are easily extensible as well.

Spoofax, relies on Stratego~\cite{Stratego2008}, a term transformation language
for defining almost all language aspects beyond the grammar. For type computation,
Spoofax predefines a transformation rule \ic{type-of} which returns the type of
a program element passed in as an argument. To define the type for a
particular language concept, the \ic{type-of} rule has to be overridden for that
concept. Below are the that that assigns an \ic{IntType} to the
\ic{Int} literal and also assigns \ic{IntType} to the \ic{Add} expression:

\begin{lstlisting}[language=Spoofax]
  type-of: Int(value) -> IntType()
  type-of: Add(exp1, exp2) -> IntType()
\end{lstlisting}

The type of \ic{Add} depends on the type of its arguments, so \ic{where} clauses
must be used to distinguish the cases:

\begin{lstlisting}[language=Spoofax]
  type-of: Add(exp1, exp2) -> IntType()
    where <type-of> exp1 => IntType() ; <type-of> exp2 => IntType()
  type-of: Add(exp1, exp2) -> StringType()
    where <type-of> exp1 => StringType() ; <type-of> exp2 => StringType()
\end{lstlisting}

Both in MPS and in Spoofax, the typing rules are declarative. If language
extensions are added, the type system for the additional language concepts can be defined by
just \emph{adding} additional cases.










OCL~\cite{WarmerKleppe99,OCLOMG} is an expression language for declaring
constraints on metamodels; while OCL is suitable for specifying constraints, it
might be harder to use it to perform type computations than Xsemantics and XTS.

EriLex~\cite{EriLex} is a software tool for embedded DSLs and it supports
specifying syntax, type rules, and dynamic semantics of such languages but it
does not generate any artifact for IDE functionalities.
On the contrary, \xtext{} shares with older tools (like
\emph{Synthesizer}~\cite{Synthesizer} and \emph{Centaur}~\cite{Centaur}) the
philosophy that the editing tooling is crucial for the programming (in
particular the immediate feedback about problems in the program being editing)
and thus a framework for implementing languages should address also this
functionality; with this respect Xsemantics and XTS aim at providing a
specification language for type systems in Xtext, to speed up the
implementation.

Differently from other approaches, such as, e.g.,
\cite{Centaur,MPS,ASFSDF,Ruler,PLTRedex,EriLex,Neverlang2010}, Xsemantics and
XTS specifications do not refer to the grammar elements of the language but only
to the structure of the EMF model representing the AST.  Thus, they might be
used with any other frameworks that represent a program in the shape of an EMF
model (though this still requires some investigation).
It would also be interesting to study how to employ Xsemantics and XTS for
modular implementation of type systems (like in, e.g.,
\cite{JastAdd,Neverlang2010,Spoofax2010}) and for implementing \emph{pluggable
type systems}~\cite{Brac04a}.

Neither Xsemantics nor XTS aim at providing mechanisms for formal proofs for the
language and the type system; for instance, they do not produce, like other
frameworks do (see, e.g., \cite{Ott}), versions of the type system for proof
assistants like Coq~\cite{Coq}, HOL~\cite{HOL} or Isabelle~\cite{Isabelle}.
Whether Xsemantics and XTS can be extended to also produce input for proof
assistants is still under investigation.
% Although this issue still needs further investigation, we think that
% specifications of rules in \xtypes{} might be good candidates for such generated
% definitions for proof assistants.

Finally, we just mention here other tools and frameworks for implementation of
DSLs that are different from \xtext{} and the type system frameworks presented
here, for the main goal and programming context, such as, e.g.,
\cite{JST98,MetaBorg06,MontiCore10} which are based on language specification
preprocessors, \cite{XMF08,LanguageBoxes09} which target host language
extensions and internal DSLs, \cite{ASFSDF,Ruler,PLTRedex} which do not target
IDE functionalities.