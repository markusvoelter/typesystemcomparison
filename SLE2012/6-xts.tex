\section{XTS}
\label{sec:xts}

\subsection{Introduction}

XTS was originally developed as a framework with a Java API to declaratively
specify type system rules. Later, a DSL was put on top of the framework which
simply generates the Java code that had to be written before.
If no suitable declarative abstraction is available, either in the framework or
in the DSL, procedural Java code can still be added manually.

XTS features the \ic{ITypesystem} interface. It has various methods for
calculating the type of model elements, and for comparing types for
compatibility and subtyping relationships. To benefit from the framework, it is
recommended to use the declarative APIs from in the \ic{DefaultTypesystem}
implementation.

\subsection{Hooking up the type checker}

To enable type checks, the type system framework  has to be hooked up with the
validation  framework provided by Xtext. Here is the validator code:

\begin{lstlisting}[language=Java] 
@Inject private ITypesystem ts;

@Check(CheckType.NORMAL)
public void validateTypes( EObject m ) {
    ts.checkTypesystemConstraints( m, this );
}    
\end{lstlisting}

The type system can be used in any other place in an Xtext DSL implementation.
For example it has been used as part of scope implementations, in which case the
type system may be reused by injecting it into the scope provider as a field.

\subsection{Setting up}

We start with the header of the type system file.

\begin{lstlisting}[language=xts] 
typesystem org.typesys.xts.guidsl.typesys.GuiDlsTypesystem 
    ecore file 
    "platform:/resource/org.typesys.xts.guidsl/src-gen/org/typesys/xts/guidsl/GuiDsl.ecore"
    language package org.typesys.xts.guidsl.guiDsl.GuiDslPackage 
\end{lstlisting}

The header specifies the fully qualified class name of the type system
implementation class generated from this specification file. We also have to
provide the platform URI for the Ecore file that contains the metaclasses for
which we want to specify the type system rules (the one generated from the Xtext
grammar). Finally, we have to provide the the fully qualified name of the
package class generated from that Ecore file.

\subsection{The type of types}

Type system specifications  are structured into sections. They have no meaning
beyond structuring the overall file. Inside sections we can define \ic{typeof}
clauses. A \ic{typeof} clause defines how the type for a given metaclass is
calculated, and can optionally specify constraints on the types of properties of
these metaclasses.

In the following piece of code we specify  that the type
of the \ic{Type} metaclass and all its subclasses (hence the \ic{+}) is a clone of itself.
In other words, types are their own types.

\begin{lstlisting}[language=xts] 
section "Types"
    typeof Type+ -> clone
    subtype IntType base FloatType
\end{lstlisting}

We also specify the subtyping relationship between \ic{FloatType} and \ic{IntType}. This
means that, wherever a \ic{FloatType} is expected, an \ic{IntType} can also be
used as well.  But not the other way around. In other words, \ic{IntType} is more
specialized.

\subsection{Literals}

The type of string literals and Boolean literals is always the same, so it can
be fixed to a specific type.
However, for number literals it is more complicated:
whether it is an integer or float type depends on the value and this cannot be
expressed declaratively in the DSL. So we declare the type for
\ic{NumberLiteral} to be calculated with Java code.

\begin{lstlisting}[language=xts] 
section "Literals"
      typeof StringLiteral -> StringType
      typeof BooleanLiteral -> BooleanType
      typeof NumberLiteral -> javacode
\end{lstlisting}
 
This specification leads to the generation of an abstract method into the
generated type system class, which we have to override in the manually written
subclass. The corresponding method looks as follows:
 
\begin{lstlisting}[language=Java] 
public EObject type( NumberLiteral s, TypeCalculationTrace trace ) {
    if ( s.getValue().equals(s.getValue().intValue())) {
        return create(cl.getIntType());
    }
    return create(cl.getFloatType());
} 
\end{lstlisting}



\subsection{Expressions}

Before we define the type system rules for the various expressions,  we first
define two characteristics. A \emph{characteristic} is essentially a set of
types. Instead of listing the set of types over and over again, we can use the
characteristic the shortcut.

\begin{lstlisting}[language=xts] 
characteristic COMPARABLE {
    IntType, FloatType, BooleanType, StringType
}  
  
characteristic NUMERIC {
    IntType, FloatType
} 
\end{lstlisting}

Then we define the type for the abstract \ic{Expression} class: it 
has no type, since it is itself abstract, and all it subclasses have different
types. However, it makes sense to declare this fact explicitly, because the type
system DSL editor can then check that all subclasses of \ic{Expression} are actually
covered by type system rules.

\begin{lstlisting}[language=xts]
typeof Expression -> abstract
\end{lstlisting}

We can now take a look at some of the more interesting cases. For comparisons,
the type will be \ic{BooleanType} and the \ic{left} and \ic{right} arguments
have to be \ic{Comparable} (see above). In addition, they also have to be compatible.
For instance, while boolean and string types are both comparable, they cannot be
compared \emph{to each other}. This is why we need this explicit compatibility check:

\begin{lstlisting}[language=xts]
 typeof Comparison -> BooleanType {
     ensureType left :<=: char(COMPARABLE)
     ensureType right :<=: char(COMPARABLE)
     ensureCompatibility left :<=>: right
 } 
\end{lstlisting}


The symbol \verb|:<=:| is called \emph{ordered} compatibility. It
means that the type on the left must be the same or a subtype of the type
specified on the right. The symbol \verb|:<=>:| represents \emph{unordered}
compatibility: the left must be the same or a subtype of the right, or vice
versa.

\begin{lstlisting}[language=xts,float,label=lst:xts-binaryexpressions,caption=Some
rules for expressions.] 
typeof Equality -> BooleanType {
    ensureType left :<=: char(COMPARABLE), BooleanType
    ensureType right :<=: char(COMPARABLE), BooleanType
    ensureCompatibility left :<=>: right
}

typeof AndOrExpression -> BooleanType {
    ensureType left :<=: BooleanType
    ensureType right :<=: BooleanType 
}   

typeof Plus -> common left right {
    ensureType left :<=: StringType, char(NUMERIC)
    ensureType right :<=: StringType, char(NUMERIC)
    ensureCompatibility left :<=>: right
} 

typeof Minus -> common left right {
    ensureType left :<=: char(NUMERIC)
    ensureType right :<=: char(NUMERIC)
    ensureCompatibility left :<=>: right
} 

typeof MultiOrDiv -> common left right { 
    ensureType left :<=: char(NUMERIC)
    ensureType right :<=: char(NUMERIC)
} 

typeof BooleanNegation -> BooleanType {
    ensureType expression :<=: BooleanType
}
\end{lstlisting}

The remainder of specifications for the binary expressions is essentially more
of the same (Listing~\ref{lst:xts-binaryexpressions}).
The only thing worth mentioning is the \ic{common} keyword. Using \ic{common} in the
type for a meta class means that the type is going to be the common supertype of the two
arguments. This only works, if the two types are either the same or part of a
subtype relationship (such as \ic{FloatType} and \ic{IntType}).

Let us now look at some more special cases: the type of the attribute reference
is the type of the referenced attribute. In other words, we have to follow the 
\ic{attr} reference to find out the type:

\begin{lstlisting}[language=xts]
typeof AttributeRef -> feature attr
\end{lstlisting}

The type of the widgets (they are not expressions, but as we will see below, it
is useful if they have a type) should also be relatively straightforward. This
is also where  the type system rules for our test case are finally implemented
(Listing~\ref{lst:xts-widgets}).

\begin{lstlisting}[language=xts,float,label=lst:xts-widgets,caption=Rules
for widgets.] 
// 1) the expression after "validate" must be boolean
typeof Widget -> abstract

// 2) text widgets may only refer to non-boolean attributes 
typeof TextWidget -> feature attr {
    ensureType length :<=: IntType
    ensureType attr :<=: StringType, IntType, FloatType
    ensureType validate :<=: BooleanType
}  

// 3) checkbox widgets may only refer to boolean attributes
typeof CheckBoxWidget -> feature attr {
    ensureType attr :<=: BooleanType
    ensureType validate :<=: BooleanType
}
\end{lstlisting}


We can now calculate the type of the \ic{FieldContent} expression, which has to have
the same type as  the attribute to which the parent widget points. Since we
have defined the type of the widget to be the type of the reference attribute,
we can now use the following type specification for \ic{FieldContent}:

\begin{lstlisting}[language=xts]
typeof FieldContent -> ancestor Widget
\end{lstlisting}

The type of \ic{NewExpr} is the type of the \ic{new}'ed entity:

\begin{lstlisting}[language=xts]
    typeof NewExpr -> feature entity
\end{lstlisting}

 Finally, the type of an \ic{Entity} also has to be calculated with Java code, because
 it has to be an \ic{EntityType} that references the corresponding entity:

\begin{lstlisting}[language=Java]
    protected EObject type(Entity element, TypeCalculationTrace trace) {
        EntityType et = (EntityType)create(cl.getEntityType());
        et.setRef(element);
        return et;
    }
\end{lstlisting}

There is one more interesting open issue. We have to implement the subtyping
relationship between entities. This is not so simple, because we compare
\ic{EntityType}s, and the subtyping depends on whether their corresponding
referenced entities are subtypes of each other. So instead of declaring a
subtype relationship in the DSL, we can implement a type comparison function in
Java. The method \emph{internalCompareTypesOrdered()} checks the entity subtype
relation with cycle detection as seen in the plain Xtext case in listing
\ref{lst:plain-type-conformance}, operation \emph{internalIsAssignable()}.


\begin{lstlisting}[language=Java]
protected boolean compareTypes( EntityType t1, EntityType t2, CheckKind k, TypeCalculationTrace trace ) {
    if ( k == CheckKind.same ) return t1.getRef() == t2.getRef();
    if ( k == CheckKind.ordered ) return internalCompareTypesOrdered(
        t1.getRef(), t2.getRef(), Sets.<Entity>newHashSet());
    return false; 
}
\end{lstlisting}


  
