\section{Plain Xtext}
\label{sec:plain-xtext}

To infer types, the plain Xtext scenario implements operations which determine
the actual type of an expression, the expected type (which depends on the
context where the expression is used), and operations which check whether a type
is assignable to another type.

The first two tasks are implemented by \mytt{GuiDslTypeProvider}, partially
shown in Listing~\ref{lst:plain-type-provider1}, written in Xtend. The method
\emph{getType()} determines the actual type of an expression. It avoids endless
loops in case of cyclic dependencies (typically due to a malformed cyclic entity
hierarchy) by caching already calculated types.  The type of a primitive type
model element as well as the type of an entity is defined to be itself. The type
of an attribute is its declared type or the type of its initialization
expression.  In case there are both an initialization expression and an explicit type, a
conformance check is made before (shown later). If that
check fails, the default (\verb|null|) of the switch statement is returned.
References to attributes have the type of the referenced attribute, and the
\emph{widgetcontent} used in validate clauses has the type of the attribute that
the widget refers to.

%Note that \verb|e.type| is the reference to a (primitive) type while \verb|e.expr.type| and \verb|e.attr.type| recursively call \emph{getType()}. They use the Xtend 2 syntax shortcut to \verb|getType(e.expr.type)| and \verb|getType(e.attr.type)|. 

%\lstinputlisting[language=xtend,label=lst:plain-type-provider1,caption=Type
%provider in Xtend.]{code/GuiDslTypeProvider.xtend}

\begin{lstlisting}[language=xtend,float=tb,label=lst:plain-type-provider1,caption=Type provider in Xtend.] 
class GuiDslTypeProvider {
	@Inject extension TypeConformance conformance
	
	// declare the built-in types for easy use
	Type bool = GuiDslFactory::eINSTANCE.createBooleanType
	Type _float = GuiDslFactory::eINSTANCE.createFloatType
	// ... similar for other basic types
	@Inject CyclicDependencyType cyclicType

	def Type getType(EObject e) { getType(e, newHashSet()) }
	
	def Type getType(EObject e, Collection<EObject> visited) {
		if (visited.contains(e)) return cyclicType; // cycle detected
		visited.add(e)
		switch e {
			Widget : e.attr.getType(visited)
			Attribute case e.expr != null && e.type != null 
			   && e.type.isAssignable(e.expr.getType(visited)) : e.type
			Attribute case e.expr != null : e.expr.getType(visited)
			Attribute case e.type != null : e.type
			AttributeRef : e.attr.getType(visited)
			AndOrExpression : bool 
			Comparison : bool
			Equality : bool
			// type is the most general, e.g. int + float => float
			Plus : mostGeneral(e.left.getType(visited), e.right.getType(visited))
			Minus : mostGeneral(e.left.getType(visited), e.right.getType(visited))
			MultiOrDiv case e.op.equals("*"): mostGeneral(e.left.getType(visited),e.right.getType(visited))
			// as in Java
			MultiOrDiv case e.op.equals("/"): e.left.getType(visited)
			
			// similar for other expressions

			default: null
		}
	} 
	def Type getExpectedType(EObject e) {
		internalGetExpectedType(e.eContainer, e.eContainingFeature) 
	} 
}
\end{lstlisting}

The operation \emph{getExpectedType()} in listing \ref{lst:plain-type-provider1}
returns the expected type of an EObject by checking its container. It calls
another operation (not shown here) with the container of the EObject and the
feature of the container pointing to it. For instance, if the container of an
expression is a \emph{Widget} and the feature of the widget containing the
expression is the \emph{validate} clause, the expected type is boolean. If the
container is a \emph{Form} and the EObject a \emph{Widget}, the expected type
must be primitive (i.e., a widget cannot directly edit an entity).
The expected type of a subtraction, multiplication and division is a
\emph{NumberType}. For an addition, it is a string, unless there is a common
type of the summands that is more specific. The method returns \emph{null} to
indicate if there is no expected type.

An important part of a type system is type conformance, i.e., whether another
type can be provided where a certain type is expected.
Listing~\ref{lst:plain-type-conformance} shows parts of the Xtend code to
compute whether a type is assignable to another, using polymorphic dispatch, (this is used by
the \mytt{GuiDslTypeProvider} shown above).
The method
\emph{isAssignable(left, right)} returns true if an element of type \emph{right}
can be used where an element of type \emph{left} is expected.
Thanks to polymorphic dispatch is used, a call to \emph{isAssignable()} will be
dispatched to the method with the most specific type parameters for the run-time
types of the arguments. The most ``general'' method has the arguments
\emph{(Type, Type)} and specifies that a type can always be assigned to itself,
or to one of its supertypes, using the type hierarchy of the EMF model generated
by the Xtext Grammar.
An entity can be assigned to another entity if it is of the same type (i.e., has
the same EMF \emph{EClass}), or if the latter is a super entity of the former.
Here, the reference \emph{superType} is not an EMF reference, but the one given
in the grammar for \emph{Entity}. Other special cases are dealt with the
following methods. As \emph{IntType} and \emph{FloatType} are on the same EMF
model inheritance hierarchy level, an assignment rule has to be explicitly
specified.

\begin{lstlisting}[language=xtend,float=tb,label=lst:plain-type-conformance,caption=Type
conformance specification (Xtend code).] 
class TypeConformance {
	def dispatch isAssignable(Type left, Type right) {
		left.eClass == right.eClass || right.eClass.EAllSuperTypes.contains(left.eClass) 
	}

	def dispatch isAssignable(EntityType left, EntityType right) {
		internalIsAssignable(left.ref, right.ref, newHashSet())
	}
	def internalIsAssignable(Entity left, Entity right, Collection<Entity> visited) {
		if (visited.contains(right)) return false; // cycle detected
		visited.add(right)
		left == right || (right.superType != null && 
			internalIsAssignable(left, right.superType, visited) )
	}
	
	def dispatch isAssignable(FloatType left, IntType right) { true }
	def dispatch isAssignable(StringType left, NumberType right) { true }

	def Type mostGeneral(Type one, Type two) {
		if (isAssignable(one, two)) one else two
	}
}
\end{lstlisting}


Finally, the validator, partially shown in listing \ref{lst:validation-plain},
uses these classes shown above.  The validation operating on text widgets checks that
the type of attribute the widget refers to is not \emph{boolean}.  The validation on
checkbox widgets, not shown in the listing, checks that the type is
\emph{boolean} in a similar way.
There is also a check which acts on any widget used to check whether the actual
type is assignable to the expected type, for instance \emph{boolean} for the
\emph{validate} clause of a widget. The expected type of an expression usually
depends on the context where the expression is in.
In case there is no expected type, for instance for an attribute whose type is
only defined by the derivation expression, the check operation just returns.
There is a similar check acting on any expression which basically makes sure
that the expression can be typed.

%\input{code/GuiDslTypeProvider.xtend}%linerange={15-23,31-42,49-57}
%\lstinputlisting[label=lst:validation-plain,caption=Xtext
% validator.,]{code/GuiDslJavaValidator.java}

\begin{lstlisting}[float=tb,label=lst:validation-plain,caption=Xtext validator.] 
public class GuiDslJavaValidator extends AbstractGuiDslJavaValidator {
	@Check
	public void check(TextWidget widget) {
		Type type = guiDslTypeProvider.getType(widget.getAttr());
		if (type.eClass() == GuiDslPackage.Literals.BOOLEAN_TYPE) {
			error("A text widget may not refer to a boolean attribute.",
					GuiDslPackage.Literals.WIDGET__ATTR, INCOMPATIBLE_TYPES);
		}
	}

	protected void checkType(EObject object, EStructuralFeature feature) {
		Type expectedType = guiDslTypeProvider.getExpectedType(object);
		Type actualType = guiDslTypeProvider.getType(object);
		if (actualType instanceof CyclicDependencyType)
			error("Type is part of a cyclic dependency.", feature, INCOMPATIBLE_TYPES);
		if (expectedType == null) return;
		if (!conformance.isAssignable(expectedType, actualType)) {
			error("Incompatible types. Expected '" + expectedType
					+ "' but was '" + actualType + "'", feature,
					INCOMPATIBLE_TYPES);
		}
	}
}
\end{lstlisting}


%\lstinputlisting[language=xtend,label=lst:plain-type-conformance,caption=Type
%conformance specification (Xtend code).]{code/TypeConformance.xtend}

% \subsection{Summary}
% The plain Xtext approach makes use of polymorphic dispatch and the Xtend syntax
% to keep the code concise, for instance with the Xtend \emph{switch} statement.
% It consists of four main parts:
% \begin{itemize}
% \item Xtend code to compute actual types recursively,
% \item an Xtend operation to compute expected types of expressions based on the container they are in,
% \item a type conformance specification, also written in Xtend, and
% \item the Xtext validator using all of the above.
% \end{itemize}

