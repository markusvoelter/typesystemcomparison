\section{Introduction}
\label{sec:introduction}
 
Developing languages is a time consuming task: language developers have to
define grammars, parsers, constraints, type systems and generators or
interpreters, and an IDE for the language users. With the rising popularity of
domain-specific languages (DSLs), there is an increasing need for better tool
support for building languages and their IDEs. Traditional parser generators
have only helped with the concrete and abstract syntax of a language. Modern
language workbenches generate editors, complete with syntax highlighting, code
completion and static error highlighting from a grammar definition,
significantly reducing the effort for implementing a language and its IDE.
Xtext~\cite{xtext} is currently one of the most popular tools for implementing
languages.
It is based on Eclipse, and, from a grammar definition, generates an
Eclipse-based editor, a parser and an abstract syntax tree based on EMF
Ecore~\cite{EMF08}.

However, language definition entails more than just the syntax and the
structure. In particular, the static semantics and the dynamic semantics have
to be defined. Dynamic semantics are typically defined via a generator or an
interpreter.  Static semantics typically involves checking constraints on the
program.
\emph{Type checking} is a specific case of constraint checking. In order to use
constraints to check if a type is valid, that type (and all other types in the
model) first have to be calculated. For non-trivial languages, type computation
can be quite elaborate.

In the context of Xtext, both the static semantics and the dynamic semantics can
be effectively implemented in Java and Xtend, a Java-like language that also provides functional
abstractions (useful for building interpreters) and so-called template expressions (useful for
building generators). Xtext, however, provides no support for defining the
static semantics, or \emph{type system}, for a language beyond implementing
typing rules in Java as part of the validation aspect. As languages become more
sophisticated, this lack of support for efficiently implementing type systems
turns out to be a major issue.

The main mechanism of type system implementation tools hence should be the
computation of the type of program elements. The type system is then integrated
with the constraint checking facilities to perform the actual type checks. More
specifically, a type system facility has to support the following
functionalities:

\begin{description}
  \item[F1] The framework must come with a facility to express arbitrary typing
  rules in a concise way. 
  \item[F2] There are a few very common cases for typing rules for which a
  concise expression of typing rules is especially important. These include the 
  assignment of fixed types to program elements, the derivation of the type of one 
  element from the type of one of its properties and the computation of common (super-)types.
  \item[F3] The framework must be robust in the sense that it reports on
  incomplete type specifications or the specification of types for AST concepts
  that do not exist (anymore).
  \item[F4] The framework must be able to compute the types for all typed
  elements in a program. 
  \item[F5]  The framework must integrate with the validation framework of the
  language development tool so typing errors can be reported together with other
  constraint errors detected in the model
\end{description}


\textbf{Contribution.} Our primary contribution is a comparison between various
approaches for implementing type systems for Xtext based languages. We start out
by showing how to implement type systems with Xtext only and then compare three
alternative approaches: XSemantics, Xtext Type System and the type system introduced 
by Xbase. We will conclude that using DSLs for defining type systems for DSLs is
a very worthwhile approach. Our secondary contribution is a brief look
at other language development tools and the ways they defined type systems for
DSLs.

The paper is structured as follows: in Section~\ref{sec:casestudy} we
introduce a case study that we will use to compare the various type system definition approaches discussed in this paper.
We then
present the implementation of the type system for this language using the
default way suggested by Xtext: an implementation in plain Java/Xtend 
in Section~\ref{sec:plain-xtext}. In Section~\ref{sec:xbase} we will show how to
integrate a DSL type system with Xbase, a reusable expression language, integrated
with Java, and shipped with Xtext. Then, we implement
the type system for our case study DSL in Xsemantics (Section~\ref{sec:xsemantics}) and 
in XTS (Xtext Type System) (Section~\ref{sec:xts}), two DSLs for implementing
type systems for Xtext. In Section~\ref{sec:evaluation} we evaluate and compare
the approaches introduced so far based on a set of criteria introduced above and
provide recommendations on when to use which approach.  We conclude the paper
with related work (Section~\ref{sec:realted}).
The
code of the implementations presented in this paper is available at \\
\url{https://github.com/markusvoelter/typesystemcomparison}.

\endinput

\subsection{Type Systems}

Every language development environment comes with a facility for checking
constraints. A \emph{constraint} is essentially a Boolean expression over parts
of a model. For the model to be valid, all constraints applicable to a model
must evaluate to \emph{true}. Type checking, however, is more than simple
constraint checks. In order to use constraints to check if a type is valid,
that type (and all other types in the model) first have to be calculated. For
non-trivial languages, type computation can be quite elaborate. The main
contribution of type system implementation tools hence is the computation of the
type of program elements. The type system is then integrated with the constraint
checking facilities to perform the actual type checks. More specifically, a type
system facility has to support the following functionalities:

\begin{description}
  \item[F1] The framework must come with a facility to express arbitrary typing
  rules in a concise way. 
  \item[F2] There are a few very common cases for typing rules for which a
  concise expression of typing rules is especially important. These include the 
  assignment of fixed types to program elements, the derivation of the type of one 
  element from the type of one of its properties and the computation of common (super-)types.
  \item[F3] The framework must be robust in the sense that it reports on
  incomplete type specifications or the specification of types for AST concepts
  that do not exist (anymore).
  \item[F4] The framework must be able to compute the types for all typed
  elements in a program. 
  \item[F5]  The framework must integrate with the validation framework of the
  language development tool so typing errors can be reported together with other
  constraint errors detected in the model.
\end{description}

% We can use F1 - F5 to refer to these when describing the various tools




%% old stuff 

Developing a compiler for a language \mv{It is not just the compiler. The whole
language definition must also be defined.} and its integration in Eclipse is
usually time consuming since it requires many phases, starting from parsing the
program, checking that is correct, up to the generation. Furthermore, these
mechanisms have to be integrated in the Eclipse IDE, which, in turn requires
more manual programming in order to provide background parsing of the program,
error marker generation, and all the tooling mechanisms to give the programmer a
good experience\mv{what is a good experience?}.  Xtext~\cite{xtext} is a
framework for language development based on Eclipse. It has successfully been
used for developing domain-specific languages (DSLs) as well as general-purpose
programming languages. It provides high-level mechanisms that significantly
simplify the development of the artifacts necessary for a fully-fledged IDE on
top of Eclipse.

Xtext makes it very easy to build simple DSLs. However, for more sophisticated
languages, the type checking phase still requires a lot of manual implementation
effort. A \emph{type system} allows to assign \emph{types} to language elements
and specify rules regarding which types are allowed where and under which
conditions\mv{We should introduce type systems more strictly and provide
references}. Checking these rules may be non-trivial, and type systems may help
to avoid boilerplate code for validation and \emph{scoping} \mv{We use the word
type system to mean type systems in general and some kind of implementation
framework that simplifies type checking. We should use it in only one way.}.
The latter determines visibilities of variables and other referenceable
elements. \mv{I would keep scoping out of the picture here. The type sys
frameworks we discuss only look at actual type checks, right?} Type checking can
occur at compile-time, or at run-time, for instance when types of variables may
only be computed at run-time. \mv{yes, and??} A developer of a language may
arbitrarily define which of his model elements he considers to be typable, what
types exist and define arbitrary rules using these types for what he considers
to be a system free of type errors.\mv{this last sentence sounds strange.}
Besides type computation, \emph{type conformance} or \emph{subtyping}, i.e., the
property that two types have to be in a generalization relationship in the type
hierarchy or that the given type is convertible to the expected type, is another
important issue in a type system.\mv{sentence too complicated. Split up?}
In summary, the most common tasks for type systems are:
assigning fixed types to language elements, being able to tell whether a type is
conformant to another type, i.e., whether a specific type can be given where
another one is expected, and deriving the types of complex expressions, e.g.
additions.\mv{and: reporting errors in case a type check fails.}

\mv{Before this contribution makes sense, don't we want to first explain that
there are tools that help with type systems in Eclipse? Beyond coding it in
Java?}

Thus, the contribution of this paper is to show how a type system can be
implemented in Xtext for languages \mv{``show how a TS can be implemented'' is
not a scientific contribution, it is a tutorial. I am *sure* this is not enough
for SLE!} which require non-trivial checks based on types. In particular, we
highlight the features of some approaches, and present two DSLs which are
specific for the task of implementing type systems and validation rules based on
types. \mv{Don't we *compare* various TS approaches?} \mv{And what is the goal?
Just show the alternatives and compare, or do we have some deeper message?
Maybe that DSLs can help with defining type systems? Or: traditionally, only
the syntax of a language was implemented with a DSL, nothing else, and we
argue, that DSLs are also useful to specify other aspects of DSLs, such as type
systems?} While we concentrate on a language that we use as a case study, all the
issues we deal with throughout the paper are typical of the task of implementing
the type system of a programming language, thus the presented techniques can be
reused in other DSL implementations. \mv{Strange Structure. I think the message
should be that what we do *is* generally usable, and the case study merely
illustrates it.}

As a case study, we will use language for modeling entities and GUI forms to
edit them (Section~\ref{sec:casestudy}); this small language includes the most
typical features to be dealt with in a type system, like type inference,
subtyping, entity inheritance, and requires some validation rules relying on
types.  In particular we first present the implementation of the type system for
this language in plain Java (by also using Xtend2, a Java-like language shipped
with Xtext) (Section~\ref{sec:plain-xtext}) and using Xbase (a reusable
expression language, integrated with Java, shipped with Xtext)
(Section~\ref{sec:xbase}). \mv{Again, we should first say that the paper is a
*comparison* of a set of Type Sys spec tools. We mention that in passing here.}
Then, we implement the type system for our case study DSL in Xsemantics
(Section~\ref{sec:xsemantics}) and in XTS (Xtext Type System)
(Section~\ref{sec:xts}) two DSLs for implementing type systems for Xtext.
We then evaluate all these mechanisms and suggest which approach might be the
best to use in certain contexts (Section~\ref{sec:evaluation}).

While this paper focuses on static type checking, the type systems presented
here may be used beyond that, e.g. for reduction rules and interpreters.  


