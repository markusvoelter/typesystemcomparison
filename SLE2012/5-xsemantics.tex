\section{Xsemantics}
\label{sec:xsemantics}

Xsemantics~\cite{lbts} (the successor of Xtypes~\cite{Bet11}) is a DSL (written
in Xtext) for writing type systems, reduction rules, interpreters (and in
general relation rules) for languages implemented in Xtext.
In this paper, we will use it for writing the rules of the type system of the
case study we are considering (Section~\ref{sec:casestudy}).
A system definition in Xsemantics is a set of judgment rules which have a
conclusion and a set of premises; these rules can act on any Java object,
though, typically, they will act on EObjects which are elements of the metamodel
of the language implemented in Xtext.  Indeed, Xsemantics relies on Xbase to
provide a rich syntax for defining rules (and premises of rules), thus giving
full access to Java types.
Starting from the definitions of these rules, Xsemantics generates Java code
that can be used in a language implemented in Xtext for scoping and validation
(it also generates a validator in Java).

Xsemantics is thought to be used by people who are at least a little familiar
with formal type systems and operational semantics: it aims at providing
a syntax which is close to the way deduction rules are written in a formal
setting~\cite{hindley:1997a,Pierce02}.
Actually, Xsemantics rules are written in the other direction with respect
to standard deduction rules: the conclusion comes before the premises; this is
just to make the IDE tooling work better, and to give a more ``programming''-like
style to rules.


% Xsemantics aims at
% providing a rich syntax for defining any kind of rules: relations among elements
% (e.g., \emph{subtyping}), \emph{static semantics} (i.e., type systems) and
% \emph{dynamic semantics} (i.e., reduction rules that can be used for
% interpreting a program).  In this paper, we will use it for writing the rules of
% the type system of the case study we are considering
% (Section~\ref{sec:casestudy}).

A Xsemantics judgment consists of a name, which has to be unique in the system;
a \textit{judgment symbol} that can be chosen from some predefined symbols; the
\textit{parameters} of the judgment; parameters of a judgments are separated by
a \textit{relation symbol} that can be chosen from some predefined symbols.
The parameters can be either input parameters (in that case they are declared as
Java parameters) or output parameters (in that case you use the keyword
\verb|output| followed by the Java type of the output parameter).
% Judgments can have any number of input parameters (though they must have at
% least one input parameter) and at most two output parameters.\footnote{In our
% experience, we never needed more than two output parameters; the extension of
% more than two output parameters is however straightforward.}

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-judgments,caption=Judgment
definitions in Xsemantics]
import org.typesys.xsem.guidsl.xsemGuiDsl.*

judgments {
	type |- Typable typable : output Type 
	isAssignable |- Type left <~ Type right // whether right is assignable to left
	mostGeneral |- Type first ~~  Type second |> output Type // the most general type between first and second
}
\end{lstlisting}

The judgment definitions for our case study are shown in
Listing~\ref{lst:xsem-judgments}.
Once the judgments of the system are declared, we can start declaring the rules.
 Each rule consists of a name, which has to be unique in the system; a
\textit{rule conclusion}; the \textit{premises} of the rule.  The rule
conclusion consists of the name of the \textit{environment} of a rule; a
\textit{judgment symbol}; the \textit{parameters} of the rules, which are
separated by a \textit{relation symbol} that can be chosen from some predefined
symbols.

The things that make a rule belong to a specific judgment are the judgment
symbol and the relation symbols (which separate the parameters); moreover the
types of the parameters of a rule must be (Java) subtypes of the corresponding types
of the judgment (or exactly the same Java types).  Two rules belonging to the
same judgment must differ for at least one input parameter's type.

The premises of a rule which are specified in a \verb|from| block can be any
Xbase expression, or a \emph{rule invocation}.  If one thinks of a rule
declaration as a function declaration, then a rule invocation corresponds to a
function invocation, thus you must specify the environment to pass to the rule,
and the arguments, both input and output arguments.
The premises of an Xsemantics rule are considered to be in a \emph{logical and}
relation and are verified in the same order they are specified in the block.
If one needs premises (or blocks of premises) in a \emph{logical or} relation,
the operator \verb|or| can be used to separate blocks of premises.
If a rule does not require any premise, we can use a special kind of rule,
called \textit{axiom}, which only has a conclusion.
In the premises you can assign values to the output parameters; and when you
invoke another rule, upon return, the output arguments will have the values
assigned in the invoked rule.

Also the concept of rule environment is taken from the type theory (usually it
is denoted by the $\g$).  It can be used to pass additional arguments to rules
(an empty environment can be passed using the keyword \mykeyb{empty}).
Furthermore, when passing an environment during a rule invocation, one
can specify additional \emph{environment mappings}, using the syntax
\lstinline[breakatwhitespace=false,breaklines=true]!key <- value!, 
where you can use any Xbase expression.
% you can also pass an environment with additional
% mappings separated by a comma (or even build an environment from scratch
% by specifying all the mappings, still separated by a comma); for instance
% \lstinline[breakatwhitespace=false,breaklines=true]!G, x <- 'foo', y <- 10! 
% or
% \lstinline[breakatwhitespace=false,breaklines=true]!x <- o.eClass, y <- (o.eClass.name == 'foo')!, 
% etc.
Note that when you pass an environment to a rule with additional mappings,
you actually pass a brand new environment, thus you will not modify the
current rule environment; if a mapping already exists in the current rule
environment, in the brand new environment (and only there) the existing mapping
will be overwritten.  Thus, the rule environment passed to a rule acts
in a stack manner.



\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-firstrules,caption=Some
examples of rules and axioms in Xsemantics.]
axiom BooleanLiteralType
	G |- BooleanLiteral lit : XsemGuiDslFactory::eINSTANCE.createBooleanType

rule AttributeRefType
	G |- AttributeRef attrRef : Type type
from { G |- attrRef.attr : type }

rule LengthOfType
	G |- LenghtOf len : XsemGuiDslFactory::eINSTANCE.createIntType
from { G |- len.expr : var StringType stringType }

rule FieldContentType
	G |- FieldContent fieldContent : Type type
from { G |- env(G, 'widgetcontent', Attribute) : type }
\end{lstlisting}

In Listing~\ref{lst:xsem-firstrules} we present some rules for the judgment
\mytt{type} (see Listing~\ref{lst:xsem-judgments}, recall that in the rules of
these judgments the second parameter is an output parameter).
For typing a literal (in the example a boolean literal) we write an axiom (since
there is no premise) and the result is a \mytt{BooleanType} (created through the
EMF factory for our language).  The rule for typing an \mytt{AttributeRef} can
be read as follows: the type of an \mytt{AttributeRef} is the type resulting
from typing the corresponding referred attribute (the feature \mytt{attr}, refer
to Listing~\ref{lst:grammar-plain}). The type of a \mytt{LenghtOf} expression is
an integer type, provided that the expression argument of \mytt{LenghtOf} has
string type.  Finally, for typing \mykeyb{widgetcontent} we make use of the
rule environment: we access the environment with the predefined function
\mykeyb{env}, by specifying the key and the expected Java type of the
corresponding value.  If no key is found in the environment or the value cannot
be assigned to the specified Java type the premise will fail.  We will show
how an environment is passed later in Listing~\ref{lst:xsem-validator}.  Thus,
this rule will type \mykeyb{widgetcontent} with the type of the corresponding
attribute. 

In an hypothetical formal type system, we would probably write these typing rules
as

\begin{center}
\begin{scriptsize}
\begin{tabular}{c@{\hspace{.5cm}}c@{\hspace{.5cm}}c@{\hspace{.5cm}}c}
\inferrule
{}
{\g \f \mykeyb{true} : \mykeyb{boolean} }
&
\inferrule
{\g \f \mytt{attr} : \T}
{\g \f \mykeyb{ref} \ \mytt{attr} : \T }
&
\inferrule
{\g \f \mytt{exp} : \mykeyb{string}}
{\g \f \mykeyb{lengthOf}(\mytt{exp}) : \mykeyb{int} }
&
\inferrule
{\g \f \g(\mykeyb{widgetcontent}) : \T}
{\g \f \mykeyb{widgetcontent} : \T }
\end{tabular}
\end{scriptsize}
\end{center}

\noindent
Note how the rules in Xsemantics (see Listing~\ref{lst:xsem-firstrules})
resemble the deduction rules typically used in formal type systems.

At runtime, upon rule invocation, the generated Java system will select the most
appropriate rule according to the runtime types of the passed argument (using
the \textit{polymorphic dispatch} mechanism provided by Xtext).
If one of the premises fails, then the whole rule will fail.
% and in turn all the stack of rule invocation will fail
In particular, if the premise is a boolean expression, it will fail if the
expression evaluates to false.  If the premise is a rule invocation, it will
fail if the invoked rule fails.

% As another example, we show in Listing~\ref{lst:xsem-attribute} the rule for
% \mytt{Attribute}.  Recall (refer to Listing~\ref{lst:grammar-plain}) that an
% attribute can have an explicit type and an initialization expression. The rule
% states that in case the type is not explicit the resulting type is the type of the
% initialization expression; otherwise, the resulting type is the explicit type of
% the attribute; however, in the latter case, if the initialization expression is
% specified, then we must make sure that the type of the expression is assignable
% to the declared type.
% 
% \begin{lstlisting}[language=xsemantics,float,label=lst:xsem-attribute,caption=Type
% rule for \mytt{Attribute}.] 
% rule AttributeType 
% 	G |- Attribute attr : Type attrType 
% from {
% 	if (attr.type != null) {
% 		if (attr.expr != null) {
% 			G |- attr.expr : var Type expType
% 			G |- attr.type <~ expType
% 		}
% 		attrType = attr.type
% 	} else {
% 		G |- attr.expr : attrType
% 	}
% }
% \end{lstlisting}
% 
% Thus, the rule in Listing~\ref{lst:xsem-attribute} relies on rules of the
% judgment \mytt{isAssignable} (see Listing~\ref{lst:xsem-judgments}); 

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-assignable,caption=Some
rules for the \mytt{isAssignable} judgment.] 
rule IsAssignableBase
	G |- Type left <~ Type right
from { left.eClass == right.eClass }

axiom BooleanAssignableToString    G |- StringType left <~ BooleanType right
axiom IntAssignableToString    G |- StringType left <~ NumberType right
axiom IntAssignableToFloat   G |- FloatType left <~ IntType right

rule EntityTypeAssignable
	G |- EntityType left <~ EntityType right
from {
	left.ref == right.ref
	or
	getAll(right.ref, XsemGuiDslPackage::eINSTANCE.entity_SuperType, XsemGuiDslPackage::eINSTANCE.entity_SuperType, typeof(Entity)).contains(left.ref)
}
\end{lstlisting}

The rules of the judgment \mytt{isAssignable} (see
Listing~\ref{lst:xsem-judgments}), which basically implements subtyping, do not
have an output parameter, they accept two types as parameters; the intention of
these rules is that they succeed if the right parameter is assignable to the
left parameter.
In Listing~\ref{lst:xsem-assignable} we present some rules for the this
judgment.  The first rule is the most general case, and states that types of the
same kind are assignable to each other (in this context ``kind'' corresponds to
EClass); moreover, we have some axioms saying that booleans and integers are
assignable to strings (for instance, like in Java, by an implicit conversion
through \mytt{toString} method).  Finally, an integer can be assigned to a
float.
For the subtyping between two \mytt{EntityType}s the idea is that \mytt{right}
can be assigned to \mytt{left} either if they are the same type (entity
subtyping is reflexive) or if \mytt{left} is a ``super entity'' (possibly
indirectly) for \mytt{right} (entity subtyping is transitive).
To avoid dealing with possible malformed cyclic hierarchies, like in the manual
implementation of the type system (see Listings~\ref{lst:plain-type-provider1}
and~\ref{lst:plain-type-conformance}) we use a predefined function of
Xsemantics, to compute the ``closure'' of a graph:

\begin{lstlisting}[language=xsemantics] 
getAll(eObject, feature to collect, feature to follow, expected type)
\end{lstlisting}

% \noindent An invocation of \mytt{getAll} will return a list of ``expected
% type'', built by collecting all the elements from ``feature to collect'' of the
% specified ``eObject'', and recursively collecting such elements by following the
% feature ``feature to follow'', but avoid possible loops in the EMF graph
% representing the AST.
In Listing~\ref{lst:xsem-assignable}, it will return all
the superclasses of \mytt{right}.  Similarly, we can get all the attributes of
an entity, including the inherited ones, by simply calling

\begin{lstlisting}[language=xsemantics] 
getAll(entity, 
		XsemGuiDslPackage::eINSTANCE.entity_Attribute,
		XsemGuiDslPackage::eINSTANCE.entity_SuperType, typeof(Attribute))
\end{lstlisting}

% \begin{lstlisting}[language=xsemantics,float,label=lst:xsem-mostgeneral,caption=Rule
% for \mytt{mostGeneral}.] 
% rule MostGeneral
% 	G |- Type first ~~ Type second |> Type mostGeneral
% from {
% 	{
% 		G |- first <~ second
% 		mostGeneral = first
% 	} or
% 		mostGeneral = second
% }
% \end{lstlisting}
% 
% The judgment \mytt{mostGeneral} (Listing~\ref{lst:xsem-judgments}) takes two
% types as input parameters and returns as output the most general between the
% two; this judgment has one simple rule, shown in
% Listing~\ref{lst:xsem-mostgeneral}.

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-binaryexp,caption=Some
rules for binary expressions.] 
rule MinusType
	G |- Minus minus : NumberType type
from {
	// require number types
	G |- minus.left : var NumberType leftType
	G |- minus.right : var NumberType rightType
	// get the most general
	G |- leftType ~~ rightType |> type
}

rule PlusType
	G |- Plus plus : Type type
from {
	// deal with any type
	G |- plus.left : var Type leftType
	G |- plus.right : var Type rightType
	// get the most general (which can also be string)
	G |- leftType ~~ rightType |> type
}
\end{lstlisting}

% \begin{figure}
% \subfloat{\lstinputlisting[language=xsemantics,resetmargins=true]{code/MinusType.xsem}}
% \hspace{20pt}
% \subfloat{\lstinputlisting[language=xsemantics,resetmargins=true]{code/PlusType.xsem}}
% \caption{Global caption}
% \end{figure}

% \begin{listing}[thp]
% \lstset{frame=none}
% \begin{tabular}{ll}
% \begin{lstlisting}[language=xsemantics]
% rule MinusType
% 	G |- Minus minus : NumberType type
% from {
% 	// require number types
% 	G |- minus.left : var NumberType leftType
% 	G |- minus.right : var NumberType rightType
% 	// get the most general
% 	G |- leftType ~~ rightType |> type
% }
% \end{lstlisting}
% \hspace{20pt}
% &
% \begin{lstlisting}[language=xsemantics]
% rule PlusType
% 	G |- Plus plus : Type type
% from {
% 	// deal with any type
% 	G |- plus.left : var Type leftType
% 	G |- plus.right : var Type rightType
% 	// get the most general (which can also be string)
% 	G |- leftType ~~ rightType |> type
% }
% \end{lstlisting}
% \end{tabular}
% \caption{Caption}
% \end{listing}


The rules for \mytt{Minus} and \mytt{Plus} are shown in
Listing~\ref{lst:xsem-binaryexp} (the rules for \mytt{mostGeneral} are not
shown).
The typing rule for \mytt{Minus} requires that the two subexpressions have a
numeric type (recall that since we specify a \mytt{NumberType} as the output
argument in rule invocation, its invocation will succeed only if the result is
assignable to \mytt{NumberType}); the resulting type will be the most general
type, thus, for instance, if one of the two subexpressions has the type
\mytt{FloatType} and the other one \mytt{IntType}, the resulting type will be
\mytt{FloatType}.  Recall that we use \mytt{+} not only as the arithmetic
operator, but also for string concatenation; in particular, if one of the
subexpression is a string, the whole expression is considered as a string
concatenation.  Thus, the rule for \mytt{Plus} computes the types of the two
subexpressions, and then gets the most general; if one of them is a string type,
the whole expression will have string type (see also subtyping rules in
Listing~\ref{lst:xsem-assignable}).

% \subsection{Rules for the Validator}
% \label{sec:xsem-validation}

In a Xsemantics system we can specify some special rules,
\mytt{checkrule}, which do not belong to any judgment. They are used by
Xsemantics to generate a Java validator for the Xtext language.  A
\mytt{checkrule} has a name, a single parameter (which is the EObject which will
be checked by the validator) and the premises (but no rule environment).  The
syntax of the premises of a \mytt{checkrule} is the same of standard rules.
Xsemantics will generate a Java validator with a \checkm{} method for each
\mytt{checkrule}; just like in Java validators for Xtext languages, you can have
many checkrules for the same JavaType (provided the rule name is unique).

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-validator,caption=Some
checkrules for the Validator.] 
checkrule AttributeTypeChecks for Attribute attribute
from { empty |- attribute : var Type type }

checkrule ValidateMustBeBoolean for Widget widget
from {
	widget.validate == null
	or 
	'widgetcontent' <- widget.attr |- widget.validate : var BooleanType boolType
}

checkrule ValidateTextWidgetAttributeNotBoolean for TextWidget widget
from {
	'widgetcontent' <- widget.attr |- widget.attr : var Type attrType
	!(attrType instanceof BooleanType)
}

checkrule ValidateCheckBoxWidgetAttributeBoolean for CheckBoxWidget widget
from { 'widgetcontent' <- widget.attr |- widget.attr : var BooleanType attrType }
\end{lstlisting}

In Listing~\ref{lst:xsem-validator} we present some checkrules for validating
the elements of our language (see Section~\ref{sec:casestudy}).  The first
checkrule basically states that an Attribute is correct if we can give it a type
(in the empty environment).  The second one accepts a Widget and ensures that
either its validate part is not specified or it has a boolean type; note that in
this case we pass to the type rule invocation an explicit environment so that we
are able to type possible occurrences of \mykeyb{widgetcontent}.  These first
two rules also show an important use of the environment: since the rule for
typing \mykeyb{widgetcontent} (Listing~\ref{lst:xsem-firstrules}) requires that
the string `widgetcontent' is bound to an attribute in the environment, and
since when typing an attribute we provide an empty environment, then a possible
occurrence of \mykeyb{widgetcontent} in an attribute's initialization expression
(which is accepted by the grammar) will be automatically (and correctly)
rejected.
The third checkrule requires that the TextWidget's attribute is not of boolean
type, while the fourth one requires that the checkbox's attribute has a boolean
type (by implicitly trying to assign the result type, in the rule invocation, to
a boolean type).
