\subsection{Usage in Xtext}

Xsemantics will generate two Java classes for each Xsemantics system:
A Java class with the same name of the system, containing all the
implementations of the system's rules; a derived class from
\mytt{AbstractDeclarativeValidator}, with a \checkm{} for each checkrule (see
Section~\ref{sec:xsem-validation}).
The generated classes rely on Google injection, and they delegate some jobs to
other classes that the programmer can inject to customize the behavior of the
generated code.

The generated validator can be used in conjunction with the language existing
Java validator (so that some checks can be implemented manually and the other
ones rely on the code generated by Xsemantics).  The other Java class,
representing the system written in Xsemantics can be used in all the other parts
of the Xtext implementation of the DSL.  A typical use is in the scope provider,
in languages where the scope of elements highly rely on types, for instance.

The generated Java class containing the rules of your system will have
public methods for the judgments of your system.  For instance, if a judgment is
defined as follows


\begin{lstlisting}[language=xsemantics] 
judgments {
	myjudgment |- MyClass1 arg1 : MyClass2 arg2 : output MyOutputClass
}
\end{lstlisting}

\noindent
the generated Java system will feature three public methods

\begin{lstlisting}[language=Java] 
public Result<MyOutputClass> myjudgment(MyClass1 arg1, MyClass2 arg2)
public Result<MyOutputClass> myjudgment(RuleEnvironment env,
	MyClass1 arg1, MyClass2 arg2)
public Result<MyOutputClass> myjudgment(
	RuleEnvironment env, RuleApplication trace,
	MyClass1 arg1, MyClass2 arg2)
\end{lstlisting}

The class \mytt{Result} is part of Xsemantics runtime, and is a wrapper for
the actual result value and a possible failure (in the shape of a \failedexc).
The value in the result will be \mytt{null} if the judgment rule failed; in that
case one might want to inspect the \failedexc.
In particular, Xsemantics provides utility methods to get the stack of all the
rule failures (also already formatted as an indented string).
In case the judgment has two output parameters, the class
\mytt{Result2} will be used which acts as a pair.
If the judgment has no output parameter, the type of the result will
be \mytt{Result<Boolean>}.

The first generated method basically only takes the arguments specified in the
judgment.  With the second version, you can also pass an environment
(generated Java code can transparently deal with null environments).
The third one is useful for testing/debugging purposes: if you pass
an instance of \ruleapptrace{} if the
method terminates with success you can then inspect the trace of all the rules
invoked together with the values used in the rules.  If the judgment fails,
you will see also the rules that failed in the rule application trace.
Xsemantics provides utility methods to get a string representation of a trace
indented, yielding an output similar to the following.

\begin{footnotesize}
\begin{verbatim}
final result provided by rule MyRule
 rule 1 used by MyRule to get to the result
  rule 2 used by rule 1
   rule 3 used by rule 2
   ...
 rule 1a used by MyRule to get to the result
  rule 2a used by rule 1a
  ...
\end{verbatim}
\end{footnotesize}
