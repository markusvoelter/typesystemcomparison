\todo{I think we should keep related work separate from the conclusion.
Relarted work is extremely imporant for SLE, and we need to treat it
accordingly!}

\section{Conclusion and Related Work}
\label{sec:conclusion}

We conclude this paper with an overview of some related work concerning Xtext
(we also refer to \cite{PP08} for a wider comparison).
and other language frameworks dealing with type system implementations.

\newcommand{\xtypes}{XTypeS}
\newcommand{\xtext}{Xtext}

\subsection{Other DSL Tools}

\todo{Discuss somewhere if and how using DSLs for type sys spec is better.}

Tools like IMP (The IDE Meta-Tooling Platform) \cite{imp09} and DLTK (Dynamic
Languages Toolkit) \cite{DLTK} only deal with IDE functionalities and do not
address type system definition specifically. 
The same is true for TCS (Textual Concrete Syntax) \cite{tcs}  
and EMFText~\cite{emftext09}. However, both rely on a meta model (abstract
syntax) expressed using EMF Ecore, so the XTS and XSemantics type system
frameworks discussed in this paper could be used with EMFText and TCS. 

JetBrains MPS \cite{MPS} and TU Delft's Spoofax~\cite{Spoofax2010} are different
and more interesting. They do not rely on EMF Ecore, so XSemantics and XTS
cannot be used for either of them. However, they come with their own support
for type system specification. 

In MPS, language developers specify declarative type system equations with a
special DSL. A solver then tries to solve all the type system equations relevant
to a given program in order to compute types for program elements and to check
the consistency of types. The following are the type equations for a local
variable declaration of the form \ic{int x = 3;}:

\begin{code} 
typeof(lvd.init) :<=: typeof(lvd.type);
\end{code}

It expresses that the type of the \ic{init} expression (the \ic{3} in the
example) must be the same or a subtype of the type of the \ic{type} property
(\ic{int} in the example). The following code shows the type calculation of an
array initialization expression (as in \ic{\{1, 2, 3.5\}}). The second line
computes the type \ic{T} as the common supertype of all the types of the
elements in the initialization expression (\ic{float} in the example). The third
line then makes the type of the complete \ic{arrInitExpr} an array of \ic{T}.

\begin{code} 
type var T
foreach ( e: init.elements ) T :<=: typeof(e)
typeof(arrInitExpr) :==: new ArrayType(T);
\end{code}

As a consequence of the declarative nature of MPS' type system specification,
type systems are easily extensible by adding new rules for new program elements.
Since MPS focusses on language extension and embedding, it is crucial that type
systems are easily extensible as well.


Spoofax, relies on Stratego~\cite{Stratego2008} term transformation language for
defining almost all language aspects beyond the grammar. For type computation,
Spoofax predefines a transformation rule \ic{type-of} returns the type of a
program element passed in as an argument. To define the the type for a
particular language concept, the \ic{type-of} rule has to be overridden for the
respective terms. Below are the that that assigns an \ic{IntType} to the
\ic{Int} literal and also assigns \ic{IntType} to the \ic{Add} expression:

\begin{code}
  type-of: Int(value) -> IntType()
  type-of: Add(exp1, exp2) -> IntType()
\end{code}

The type of \ic{Add} depends on the type of its arguments, so \ic{where} clauses
must be used to distinguish the cases:

\begin{code}
  type-of:
    Add(exp1, exp2) -> IntType()
    where <type-of> exp1 => IntType() ;
          <type-of> exp2 => IntType()

  type-of:
    Add(exp1, exp2) -> StringType()
    where <type-of> exp1 => StringType() ;
          <type-of> exp2 => StringType()
\end{code}

Just as in MPS, the typing rules are declarative. If language extensions are
added, the type system for the additional language concepts can be defined by
just \emph{adding} additional \ic{type-of} cases.










OCL~\cite{WarmerKleppe99,OCLOMG} is an expression language for declaring
constraints on metamodels; while OCL is suitable for specifying constraints, it
might be harder to use it to perform type computations than Xsemantics and XTS.

EriLex~\cite{EriLex} is a software tool for embedded DSLs and it supports
specifying syntax, type rules, and dynamic semantics of such languages but it
does not generate any artifact for IDE functionalities.
On the contrary, \xtext{} shares with older tools (like
\emph{Synthesizer}~\cite{Synthesizer} and \emph{Centaur}~\cite{Centaur}) the
philosophy that the editing tooling is crucial for the programming (in
particular the immediate feedback about problems in the program being editing)
and thus a framework for implementing languages should address also this
functionality; with this respect Xsemantics and XTS aim at providing a
specification language for type systems in Xtext, to speed up the
implementation.

Differently from other approaches, such as, e.g.,
\cite{Centaur,MPS,ASFSDF,Ruler,PLTRedex,EriLex,Neverlang2010}, Xsemantics and
XTS specifications do not refer to the grammar elements of the language but only
to the structure of the EMF model representing the AST.  Thus, they might be
used with any other frameworks that represent a program in the shape of an EMF
model (though this still requires some investigation).
It would also be interesting to study how to employ Xsemantics and XTS for
modular implementation of type systems (like in, e.g.,
\cite{JastAdd,Neverlang2010,Spoofax2010}) and for implementing \emph{pluggable
type systems}~\cite{Brac04a}.

% \xtypes{} does not aim at providing mechanisms for formal proofs for the
% language and the type system; for instance, it does not produce, like other
% frameworks do (see, e.g., \cite{Ott}), versions of the type system for proof
% assistants like Coq~\cite{Coq}, HOL~\cite{HOL} or Isabelle~\cite{Isabelle}.
% Although this issue still needs further investigation, we think that
% specifications of rules in \xtypes{} might be good candidates for such generated
% definitions for proof assistants.

Finally, we just mention here other tools and frameworks for implementation of
DSLs that are different from \xtext{} and the type system frameworks presented
here, for the main goal and programming context, such as, e.g.,
\cite{JST98,MetaBorg06,MontiCore10} which are based on language specification
preprocessors, \cite{XMF08,LanguageBoxes09} which target host language
extensions and internal DSLs, \cite{ASFSDF,Ruler,PLTRedex} which do not target
IDE functionalities.