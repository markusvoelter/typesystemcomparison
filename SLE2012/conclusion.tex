\section{Conclusion and Related Work}
\label{sec:conclusion}

We conclude this paper with an overview of some related work concerning Xtext
(we also refer to \cite{PP08} for a wider comparison).
and other language frameworks dealing with type system implementations.

\newcommand{\xtypes}{XTypeS}
\newcommand{\xtext}{Xtext}

Tools like IMP (The IDE Meta-Tooling Platform) \cite{imp09} and DLTK (Dynamic
Languages Toolkit) \cite{DLTK} only deal with IDE functionalities.
MPS (Meta Programming System) \cite{MPS} provides IDE functionalities, but it
does not target Eclipse and its well-known functionalities.
TCS (Textual Concrete Syntax) \cite{tcs} is similar to \xtext; however, with the
Xtext we can describe the abstract and concrete syntax at once.
EMFText~\cite{emftext09}, instead of deriving a metamodel from the grammar like
Xtext, does the opposite:
the language to be implemented must be defined in an abstract way using an EMF
metamodel.  Spoofax~\cite{Spoofax2010}, another language workbench which targets
Eclipse, allows changes to the language to be dynamically loaded into the
environment; for the analysis of a program it relies on
Stratego~\cite{Stratego2008} for rule-based specifications.
OCL~\cite{WarmerKleppe99,OCLOMG} is an expression language for declaring
constraints on metamodels; while OCL is suitable for specifying constraints, it
might be harder to use it to perform type computations than Xsemantics and XTS.

EriLex~\cite{EriLex} is a software tool for embedded DSLs and it supports
specifying syntax, type rules, and dynamic semantics of such languages but it
does not generate any artifact for IDE functionalities.
On the contrary, \xtext{} shares with older tools (like
\emph{Synthesizer}~\cite{Synthesizer} and \emph{Centaur}~\cite{Centaur}) the
philosophy that the editing tooling is crucial for the programming (in
particular the immediate feedback about problems in the program being editing)
and thus a framework for implementing languages should address also this
functionality; with this respect Xsemantics and XTS aim at providing a
specification language for type systems in Xtext, to speed up the
implementation.

Differently from other approaches, such as, e.g.,
\cite{Centaur,MPS,ASFSDF,Ruler,PLTRedex,EriLex,Neverlang2010}, Xsemantics and
XTS specifications do not refer to the grammar elements of the language but only
to the structure of the EMF model representing the AST.  Thus, they might be
used with any other frameworks that represent a program in the shape of an EMF
model (though this still requires some investigation).
It would also be interesting to study how to employ Xsemantics and XTS for
modular implementation of type systems (like in, e.g.,
\cite{JastAdd,Neverlang2010,Spoofax2010}) and for implementing \emph{pluggable
type systems}~\cite{Brac04a}.

% \xtypes{} does not aim at providing mechanisms for formal proofs for the
% language and the type system; for instance, it does not produce, like other
% frameworks do (see, e.g., \cite{Ott}), versions of the type system for proof
% assistants like Coq~\cite{Coq}, HOL~\cite{HOL} or Isabelle~\cite{Isabelle}.
% Although this issue still needs further investigation, we think that
% specifications of rules in \xtypes{} might be good candidates for such generated
% definitions for proof assistants.

Finally, we just mention here other tools and frameworks for implementation of
DSLs that are different from \xtext{} and the type system frameworks presented
here, for the main goal and programming context, such as, e.g.,
\cite{JST98,MetaBorg06,MontiCore10} which are based on language specification
preprocessors, \cite{XMF08,LanguageBoxes09} which target host language
extensions and internal DSLs, \cite{ASFSDF,Ruler,PLTRedex} which do not target
IDE functionalities.