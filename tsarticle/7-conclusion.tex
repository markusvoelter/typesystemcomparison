\section{Comparison}

Xtext DSL projects may reduce the effort needed to write and maintain validation
constraints by using type systems or type system approaches. This section
provides guidelines which help in the decision which approach to use for the
project at hand. Each section of the guideline features a small summary
table. Criteria to be considered include:

  \begin{itemize}
    \item Coupling of the DSL with Java
    \item Expressivity
    \item Verbosity/conciseness
    \item Customizability
    \item Additional features
    \item Target audience
    \item Learning curve
    \item Documentation
    \item Support
  \end{itemize}

\begin{tabularx}{\linewidth}{ X   X }
\multicolumn{2}{c}{Target Type Systems in DSL Project} \\ \hline
Java Type System & Other Type Systems \\ \hline
Xbase & Plain  \\
& Xsem  \\
& XTS  \\
\end{tabularx}

A tight coupling to Java means that the DSL may refer to Java types, and/or that
Java artifacts will be generated from the DSL models, potentially including Java
code derived from expressions in the DSL. If the DSL is tightly coupled to Java,
using Xbase saves time for several tasks. The DSL may directly refer to Java
types and expressions (by using the Xbase library), and the
\emph{JvmModelInferrer} provides a concise way to maps DSL concepts to Java.
From this mapping, Java classes are (automatically) generated. As the Java type
system is reused, no type constraint rules have to be implemented manually for
instance for expressions which can be used in operation bodies. If the target
language of the project is not Java, the strengths of Xbase cannot be fully
leveraged and one of the other approaches (manual implementation, Xsemantics or
XTS) might be used instead.

\begin{tabularx}{\linewidth}{ l   X }
\multicolumn{2}{c}{Expressivity} \\ \hline
Plain & Java \\
Xbase & Xbase library \\
Xsem & similar to Xbase + specific syntax\\
XTS & EMF feature access + specific syntax\\
\end{tabularx}

\noindent The manual implementation presented here makes heavy use of Xtend to
keep the code concise, especially of the \emph{switch} statement and the polymorphic
dispatch. The Xbase approach offers to refer to Xbase expressions in the DSL,
which may then be compiled to Java expressions.

Xsemantics \ldots

XTS offers its specific syntax for the most common tasks when defining type
constraints. These include specifyng that the type of an element is
itself, subtype relationships and compatibilty constraints, grouping several
elements (\emph{characteristic}) to save constraint code, and access to EMF
features of model elements which allows to specify that a model element has the
type of one of its features. Like all approaches, it allows custom Java
methods for type computation.

\begin{tabularx}{\linewidth}{ l   X }
\multicolumn{2}{c}{Verbosity/conciseness} \\ \hline
Plain & $\approx$11KB \\% - \emph{TypeProvider}, \emph{TypeConformance},
% validator \\
Xbase &$\approx$5KB \\%- \emph{JvmModelInferrer}, validator\\
Xsem & $\approx$5KB \\%- \emph{*.xsemantics} file, validator\\
XTS & $\approx$4KB \\%- \emph{*.ts} file, validator\\
\end{tabularx}

\noindent As code size is a potentially misleading metric, this critera should
be considered with a grain of salt. The metric in the table is the number of
characters without spaces of (Xtend or Java) classes responsible for type
computation and validation after removing comments for each of the approaches.
The metric includes the respective Xtext validator classes of all approaches. In
the plain approach, \emph{TypeProvider}, \emph{TypeConformance} were taken into
consideration. For the Xbase approach, the \emph{JvmModelInferrer} was taken
while for Xsemantics and XTS, their \emph{.xsemantics} and \emph{.ts} files were
counted, respectively. For the particular example presented in this paper and
under the conditions stated, the manual approach seems to take more space while
the other approaches seem to have about the same size.

TODO: corner cases in plain approach?

TODO: kill this altoghether?
 
\begin{tabularx}{\linewidth}{ l   X }
\multicolumn{2}{c}{Customizability} \\ \hline
Plain & - \\
Xbase & Xbase framework \\
Xsem & custom Java methods (generation gap pattern)\\
XTS & custom Java methods (generation gap pattern) \\
\end{tabularx}

In case a framework does not provide means or a syntax for special cases,
customizability is important. This criteria does not apply to the plain
approach, as the plain approach is just a manual implementation according to a
pattern (type provider, type conformance computation and validator) which can be
extended directly. 

\begin{tabularx}{\linewidth}{ l   X }
\multicolumn{2}{c}{Additional Features} \\ \hline
Plain & - \\
Xbase & generated Java classes for free \\
Xsem & generic rules (not only typing), generates validators \\
XTS & generates validators, recurrent typing patterns \\
\end{tabularx}

\begin{tabularx}{\linewidth}{ l   X }
\multicolumn{2}{c}{Target audience} \\ \hline
Plain & - \\
Xbase & - \\
Xsem & people familiar with formal systems \\
XTS & - \\
\end{tabularx}

\begin{tabularx}{\linewidth}{ l   X }
\multicolumn{2}{c}{Learning curve} \\ \hline
Plain & Xtend \\
Xbase & Xbase, \emph{JvmModelInferrer} methods \\
Xsem & similar to rules written in commonly used type theory \\
XTS & XTS documentation \\
\end{tabularx}

footprint: learn language, additional editors and dependencies

\begin{tabularx}{\linewidth}{ l   X }
\multicolumn{2}{c}{Documentation} \\ \hline
Plain & Xtext/Xtend in general \\
Xbase & Xtext documentation \emph{JvmModelInferrer} \\
Xsem & http://xsemantics.sourceforge.net/ \\
XTS & http://code.google.com/a/eclipselabs.org/p/xtext-typesystem/ \\
\end{tabularx}

TODO: Combine with learning curve?

\begin{tabularx}{\linewidth}{ l   X }
\multicolumn{2}{c}{Support} \\ \hline
Plain & - \\
Xbase & - \\
Xsem & - \\
XTS & - \\
\end{tabularx}

TODO: kill?

\note{
TODO
functional scalability: plain only has required features, not more
may scale to function rich implementation, xbase was developed with this
architecture, type inference and typesystem (generics) not possible with XTS
}

 \section{Conclusion}

Outlook, talk about interpreter and other capabilities of XTS and Xsemantics

Xsemantics 

provides examples of a type system for Featherweight Java and
type inference of lambda calculus
 
XTS (talk about interpreter)

