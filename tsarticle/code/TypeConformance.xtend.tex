class TypeConformance {
	def dispatch isAssignable(Type left, Type right) {
		left.eClass == right.eClass || right.eClass.EAllSuperTypes.contains(left.eClass) 
	}
	def dispatch isAssignable(EntityType left, EntityType right) {
		internalIsAssignable(left.ref, right.ref, newHashSet())
	}
	
	def internalIsAssignable(Entity left, Entity right, Collection<Entity> visited) {
		if (visited.contains(right)) return false; // cycle detected
		visited.add(right)
		left == right || (right.superType != null && 
			internalIsAssignable(left, right.superType, visited) )
	}
	
	// allow ints where floats are expected
	def dispatch isAssignable(FloatType left, IntType right) { true }

	// allow numbers where strings are expected
	def dispatch isAssignable(StringType left, NumberType right) { true }
		
	// don't allow null type assignments
	def dispatch isAssignable(Type left, Void right) { false }
	def dispatch isAssignable(Void left, Type right) { false }
