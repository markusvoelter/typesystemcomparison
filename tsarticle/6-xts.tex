\section{XTS}
\label{sec:xts}

\subsection{Introduction}

XTS was originally developed as a framework. The type system rules  had been
specified declaratively via a Java API. Later, the DSL was put on top of the
framework. The DSL simply generates the Java code you would have written
manually without the DSL. For some aspects of type systems you still have to
write procedural Java code, because no suitable declarative abstraction is
available, either in the framework or in the DSL.

At the center of XTS is the ITypesystem interface. It has various methods for
calculating the type of model elements, and for comparing types for
compatibility and subtyping relationships. In principle, you can implement this
interface anyway you like. however, to benefit from the framework, you should
use the declarative APIs used in the DefaultTypesystem implementation.

\subsection{Hooking up the type checker}

To enable type checks, you have to hook up the type system framework  with the
validation  framework provided by Xtext. Here is the code you have to write in
the validator:

\begin{lstlisting}[language=Java] 
@Inject private ITypesystem ts;

@Check(CheckType.NORMAL)
public void validateTypes( EObject m ) {
    ts.checkTypesystemConstraints( m, this );
}    
\end{lstlisting}

The type system can be used, mostly in the same way as shown above, in any other
place in an Xtext DSL implementation.
For example it has been used as part of scope implementations. In this case, you
simply inject the type system into the scope provider and use it from there.

\subsection{Setting up}

Note: to be able to use the type system DSL you have to download and install the
type system plug-ins from TODO

We start with the header of the type system file.

\begin{lstlisting}[language=xts] 
typesystem org.typesys.xts.guidsl.typesys.GuiDlsTypesystem 
    ecore file 
    "platform:/resource/org.typesys.xts.guidsl/src-gen/org/typesys/xts/guidsl/GuiDsl.ecore"
    language package org.typesys.xts.guidsl.guiDsl.GuiDslPackage 
\end{lstlisting}

The header of the type system file specifies the fully qualified class name of
the type system implementation file generated from this specification file. We
also have to provide the platform URI for the Ecore file that contains the
metaclasses for which we want to specify the type system rules. Finally, we have
to provide the the fully qualified name  to the package class  generated from
that Ecore file.

\subsection{The type of types}

Type system specifications  are structured into sections. They have no meaning
beyond structuring the overall file. Within this section we can define typeof
clauses. A typeof clause defines how the type for a given metaclass is
calculated, and can optionally specify constraints on the types of properties of
these metaclasses.

In the initial section in the following piece of code we specify  that the type
of the Type metaclass and all its subclasses (hence the +) is a clone of itself.
In other words, types of their own types.

\begin{lstlisting}[language=xts] 
section "Types"
    typeof Type+ -> clone
    subtype IntType base FloatTyoe
\end{lstlisting}

We also specify the subtyping relationship between FloatType and IntType. This
means that, wherever a FloatType is expected, an IntType can also be used.  But
not the other way around. In other words, IntType is more specialized.

\subsection{Literals}

The type of string literals and Boolean literals is always the same, so it can
be fixed to a specific type.
However, for number literals it is more complicated:
whether it is an integer or float type depends on the value and this cannot be
expressed declaratively in the DSL. So we declare the type for NumberLiteral to be calculated with Java
code.

\begin{lstlisting}[language=xts] 
section "Literals"
      typeof StringLiteral -> StringType
      typeof BooleanLiteral -> BooleanType
      typeof NumberLiteral -> javacode
\end{lstlisting}
 
This specification leads to the generation of an abstract method into the
generated type system class, which we have to override in the manually written
subclass. The corresponding method looks as follows:
 
\begin{lstlisting}[language=Java] 
public EObject type( NumberLiteral s, TypeCalculationTrace trace ) {
    if ( s.getValue().equals(s.getValue().intValue())) {
        return create(cl.getIntType());
    }
    return create(cl.getFloatType());
} 
\end{lstlisting}



\subsection{Expressions}

Before we define the type system rules for the various expressions,  we first
define two characteristics. A \emph{characteristic} is essentially a set of
types:
instead of listing the set of types over and over again, we can use the
characteristic the shortcut.

\begin{lstlisting}[language=xts] 
characteristic COMPARABLE {
    IntType, FloatType, BooleanType, StringType
}  
  
characteristic NUMERIC {
    IntType, FloatType
} 
\end{lstlisting}

Then we define the abstract type for the Expression class: such class
has no type, since it is itself abstract, and all it subclasses have different
types. However, it makes sense to declare this fact explicitly, because the type
system DSL editor can then check that all subclasses of Expression are actually
covered by type system rules.

\begin{lstlisting}[language=xts]
typeof Expression -> abstract
\end{lstlisting}

We can now take a look at some of the more interesting cases. For comparisons,
the left and right arguments  have to be comparable (see above). In addition,
they also have to be compatible. For instance, while boolean and string types
are both comparable, they cannot be compared to each other. This is why we need
this explicit compatibility check:

\begin{lstlisting}[language=xts]
 typeof Comparison -> BooleanType {
     ensureType left :<=: char(COMPARABLE)
     ensureType right :<=: char(COMPARABLE)
     ensureCompatibility left :<=>: right
 } 
\end{lstlisting}


The symbol \verb|:<=:| is called ordered compatibility. It
means that the type on the left must be the same or a subtype of the type
specified on the right. The symbol \verb|:<=>:| represents unordered
compatibility: the left must be the same or a subtype of the right, or vice
versa.

\begin{lstlisting}[language=xts,float,label=lst:xts-binaryexpressions,caption=Some
rules for expressions.] 
typeof Equality -> BooleanType {
    ensureType left :<=: char(COMPARABLE), BooleanType
    ensureType right :<=: char(COMPARABLE), BooleanType
    ensureCompatibility left :<=>: right
}

typeof AndOrExpression -> BooleanType {
    ensureType left :<=: BooleanType
    ensureType right :<=: BooleanType 
}   

typeof Plus -> common left right {
    ensureType left :<=: StringType, char(NUMERIC)
    ensureType right :<=: StringType, char(NUMERIC)
    ensureCompatibility left :<=>: right
} 

typeof Minus -> common left right {
    ensureType left :<=: char(NUMERIC)
    ensureType right :<=: char(NUMERIC)
    ensureCompatibility left :<=>: right
} 

typeof MultiOrDiv -> common left right { 
    ensureType left :<=: char(NUMERIC)
    ensureType right :<=: char(NUMERIC)
} 

typeof BooleanNegation -> BooleanType {
    ensureType expression :<=: BooleanType
}
\end{lstlisting}

The remainder of specifications for the binary expressions is essentially more
of the same (Listing~\ref{lst:xts-binaryexpressions}).
The only thing worth mentioning is the \mykeyb{common} keyword. Using common in the
type for a meta class means that the type is going to be the common supertype of the two
arguments. This only works, if the two types are either the same or top of a
subtype relationship (such as float and int).

Let us now see some more special cases: the type of the attribute reference
is the type of the referenced attribute. In other words, we have to follow the 
attr reference to find out the type:

\begin{lstlisting}[language=xts]
typeof AttributeRef -> feature attr
\end{lstlisting}

The type of the widgets (although they are not expressions, but as we will see
below, it is useful if they have a type) should also be relatively
straigthforward.
This is also where  the type system rules for our  test case are  finally
implemented (Listing~\ref{lst:xts-widgets}).

\begin{lstlisting}[language=xts,float,label=lst:xts-widgets,caption=Rules
for widgets.] 
// 1) the expression after "validate" must be boolean
typeof Widget -> abstract

// 2) text widgets may only refer to non-boolean attributes 
typeof TextWidget -> feature attr {
    ensureType length :<=: IntType
    ensureType attr :<=: StringType, IntType, FloatType
    ensureType validate :<=: BooleanType
}  

// 3) checkbox widgets may only refer to boolean attributes
typeof CheckBoxWidget -> feature attr {
    ensureType attr :<=: BooleanType
    ensureType validate :<=: BooleanType
}
\end{lstlisting}


We can now calculate the type of the field content expression, which has to have
the same type as  the attribute to which the owning widget points. Since we
have defined the type of the widget to be the type of the reference attribute,
we can now use the following type specification for FieldContent:

\begin{lstlisting}[language=xts]
typeof FieldContent -> ancestor Widget
\end{lstlisting}

The type of NewExpr is the type of the new'ed entity:

\begin{lstlisting}[language=xts]
    typeof NewExpr -> feature entity
\end{lstlisting}

Finally, the type of an Entity also has to be calculated with Java code, because
it has to be an entity type that references the corresponding entity:

\begin{lstlisting}[language=Java]
protected boolean compareTypes( EntityType t1, EntityType t2, CheckKind k, TypeCalculationTrace trace ) {
    if ( k == CheckKind.same ) return t1.getRef() == t2.getRef();
    if ( k == CheckKind.ordered ) return t1.getRef().getExtends() == t2.getRef();
    return false;
}
\end{lstlisting}


There is one more interesting open issue. We have to implement the subtyping
relationship between entities. This is not so simple, because we will compare 
EntityTypes, and the subtyping depends on whether their corresponding referenced
entities are subtypes of each other. So instead of declaring a subtype relationship
in the DSL, we can implement a type comparison function in Java:

\begin{lstlisting}[language=Java]
protected boolean compareTypes( EntityType t1, EntityType t2, CheckKind k, TypeCalculationTrace trace ) {
    if ( k == CheckKind.same ) return t1.getRef() == t2.getRef();
    if ( k == CheckKind.ordered ) return extends( t1.getRef(), t2.getRef() );
    return false; 
}
\end{lstlisting}








The type of the FieldContent expression also has to be calculated with Java
code, because it involves relatively complicated model navigation that cannot be
expressed declaratively.








\subsection{Learn more}

XTS docs
  