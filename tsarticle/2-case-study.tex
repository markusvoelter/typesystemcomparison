\section{Case Study}
\label{sec:casestudy}

As a practial example where type inference and validation is useful, we present
a language for modeling forms in a GUI to edit entities in a database.  An
entity may have attributes of base types like \emph{boolean}, \emph{string},
\emph{int} and \emph{float}, or entity types.
Attributes can have an explicit type and an initialization expression.
If the attribute has an explicit type and an initialization expression, we
require that the (inferred) type of the expression is a subtype of the
attribute's type.  If the attribute has no explicit type then the (in this case
mandatory) initialization expression is used to infer the type of the attribute.

Since entities can specify an entity to derive from, we also have a subtyping
relation on entity types implied by the transitive closure of \mykeyb{extends}
relation.

The forms are wired to entities and have widgets like text fields and
checkboxes which refer to a specific attribute of the entity.
Widgets of forms may contain a \emph{validate} clause, which verifies for
example the length of the input.

In order to compare the different approaches for type systems, the case study is
implemented for each of the following variants.

\begin{itemize}
\item Plain Xtext/Xtend (Section~\ref{sec:plain-xtext})
\item Xtext with Xbase (Section~\ref{sec:xbase})
\item Xtext with XSemantics (Section~\ref{sec:xsemantics})
\item Xtext with Xtext/TS (Section~\ref{sec:xts})
\end{itemize}

Listing \ref{lst:example-plain} shows an example of the DSL with a \emph{Person}
entity and a \emph{PersonForm} to edit it. Note that the attribute
\emph{isAdult} has an explicit type, and its initialization expression
comforms to that type; \emph{greeting} has no explicit type, and its type is
inferred from its initialization expression.
They could be read-only widgets in forms.

%\lstinputlisting[language=bash,label=lst:example-plain,caption=Forms and
% Entities DSL,linerange={1-16}]{..//exampleCode/src/plain-xtext.gui}

%float,
\begin{lstlisting}[language=guidsl,float,label=lst:example-plain,caption=Forms
and Entities DSL.] 
entity Person {
	name      : string;
	firstName : string;
	age       : int; 
	weight    : float;
	likesCake : bool; 
	isAdult : bool = age > 18;
	greeting = "Hello " + firstName + " " + name + "!";
}

form PersonForm edits Person {
	text (20) -> name validate lengthOf(widgetcontent) >= 2;
	text (20) -> firstName;
	text (5) -> age validate 12.5 > widgetcontent;
	text (5) -> weight validate 0 < widgetcontent;
	checkbox -> isAdult;
	text (30) -> greeting;
}
\end{lstlisting}

In widgets' validate expressions, one can access the attribute by means of
\mykeyb{widgetcontent}, which will then have the type of the corresponding
attribute.

%\lstinputlisting[label=lst:grammar-plain,caption=Grammar with plain
% Xtext,linerange={7-53}]{../org.typesys.guidsl/src/org/typesys/guidsl/GuiDsl.xtext}

%float
\begin{lstlisting}[language=xtext,float,label=lst:grammar-plain,caption=Grammar
with plain Xtext.] 
Model: (entities+=Entity | forms+=Form )*;

Entity: "entity" name=ID ('extends' superType=[Entity])? "{"
			(attributes+=Attribute)*
		"}";

Attribute: name=ID ( ((":" type=Type)? "=" expr=Expression) | 
               (":" type=Type) )";";

Form: "form" name=ID "edits" entity=[Entity] "{"	
		(widgets+=Widget)*
	  "}";

Widget: TextWidget | CheckBoxWidget ;

TextWidget:
	"text" "(" length=Number ")" "->" attr=[Attribute] 
	("validate" validate=Expression)? ";";

CheckBoxWidget:
	"checkbox" "->" attr=[Attribute] ("validate" validate=Expression)? ";" ;
\end{lstlisting}

The Xtext grammar part used by all variants is shown in listing
\ref{lst:grammar-plain}. The type and expressions definition part of the grammar
in listing \ref{lst:grammar-plain-types-and-ex} is the same for the the plain
Xtext grammar and the XSemantics and Xtext/TS grammars. 
The rule \mytt{Typable} is not called by any other rule of the grammar: it is
only useful to create a common superclass for \mytt{Attribute} and
\mytt{Expression} which are the elements we want to type.

\begin{lstlisting}[language=xtext,float,label=lst:grammar-plain-types-and-ex,caption=Types
and Expressions.] 
Typable: Attribute | Expression;

Type: PrimitiveType | EntityType;

EntityType: ref=[Entity];

PrimitiveType: NumberType | BooleanType | StringType;

NumberType: FloatType | IntType;

FloatType:   {FloatType}   "float";
IntType:     {IntType}     "int";
BooleanType: {BooleanType} "bool";
StringType:	 {StringType}  "string";

Expression: BooleanExpression;

BooleanExpression returns Expression:
       Comparison
       (({AndOrExpression.left=current} op=("||"|"&&")) right=Comparison)*;

Comparison returns Expression:
       EqualsStuff (({Comparison.left=current} op=(">="|"<="|"<"|">")
       ) right=EqualsStuff)*;

EqualsStuff returns Expression:
       Addition 
       (({Equality.left=current} op=("=="|"!=")) right=Addition)*;

Addition returns Expression:
       Multiplication (({Plus.left=current} '+' | {Minus.left=current} '-') 
        right=Multiplication)*;

Multiplication returns Expression:
       Prefixed (({MultiOrDiv.left=current} op=("*"|"/")) right=Prefixed)*;

Prefixed returns Expression:
       {BooleanNegation} =>"!" expression=Atomic | /* right associativity */
       {ArithmeticSigned} =>"-" expression=Atomic | /* right associativity */
       Atomic;

Atomic returns Expression:
       '(' Expression ')' |
       ({FieldContent} "widgetcontent") |
       ({LengthOf} "lengthOf" "(" expr=Expression ")" ) |
       ({EntityType} "new" ref=[Entity]) | 
       ({BooleanLiteral} value=("true"|"false")) |
       ({FloatLiteral} value=Float) |
       ({IntLiteral} value=INT) |
       ({StringLiteral} value=STRING) |
       ({AttributeRef} attr=[Attribute|ID]);

Float returns ecore::EBigDecimal:   INT? ('.' INT);
Number returns ecore::EBigDecimal: INT ('.' INT)?;
\end{lstlisting}

%\lstinputlisting[label=lst:grammar-plain-types-and-ex,caption=Grammar with
% plain Xtext,linerange={54-120}]{../org.typesys.guidsl/src/org/typesys/guidsl/GuiDsl.xtext}


The rule order reflects
the precedence hierarchy of the operators, from lowest
(\emph{BooleanExpression}) to highest (\emph{Atomic}). The rules use
\emph{assigned actions} to produce an appropriate abstract syntax tree (cf.
Xtext documentation \cite{xtextdoc}), which is used when checking types.
In the Xbase scenario, the rule \emph{Expression} is replaced with the Xbase
\emph{XExpression} rule, which maps to Java types and expressions.
% float,


\subsection{Demonstration Tasks}
To compare the different type system variants, each of them will show its type
checking ability by demonstrating how it solves the following tasks.
\begin{enumerate}
\item Ensure that the expression after the \emph{validate} clause is boolean.
\item Show an error message when text widgets refer to boolean entity attributes.
\item Validate that checkbox widgets may only refer to boolean attributes.
\end{enumerate}

All tasks imply being able to infer the type of expressions: The \emph{validate}
clause is an expression, and widgets and checkboxes may refer to derived
attributes, which are defined with expressions. Test cases for the projects are
online at []%TODO
