\section{Case Study}
\label{sec:casestudy}

As a practial example where type inference and validation is useful, we present a language for modeling forms in a GUI to edit entities in a database. The forms are wired to entities and have widgets like text fields and checkboxes. An entity may have simple attributes of base types like \emph{boolean}, \emph{string}, \emph{int} and \emph{float} and derived attributes. The latter have a specification on how to derive them, which may refer to other attributes. Widgets of forms may contain a \emph{validate} clause, which verifies for example the length of the input. 
In order to compare the different approaches for type systems, the case study is implemented for each of the following variants.

\begin{itemize}
\item Plain Xtext/Xtend
\item Xtext with Xbase
\item Xtext with XSemantics
\item Xtext with Xtext/TS
\end{itemize}

Listing \ref{lst:example-plain} shows an example of the DSL with a \emph{Person} entity and a \emph{PersonForm} to edit it. The attributes \emph{isAdult} and \emph{greeting} are derived, thus it is not necessary to specify their type explicitly. They could be read-only widgets in forms.

%\lstinputlisting[language=bash,label=lst:example-plain,caption=Forms and
% Entities DSL,linerange={1-16}]{..//exampleCode/src/plain-xtext.gui}

%float,
\begin{lstlisting}[language=guidsl,label=lst:example-plain,caption=Forms
and Entities DSL.] 
entity Person {
	name      : string;
	firstName : string;
	age       : int; 
	weight    : float;
	likesCake : bool; 
	isAdult : bool = age > 18;
	greeting = "Hello " + firstName + " " + name + "!";
}

form PersonForm edits Person {
	text (20) -> name validate lengthOf(widgetcontent) >= 2;
	text (20) -> firstName;
	text (5) -> age validate 12.5 > widgetcontent;
	text (5) -> weight validate 0 < widgetcontent;
	checkbox -> isAdult;
	text (30) -> greeting;
}
\end{lstlisting}

%\lstinputlisting[label=lst:grammar-plain,caption=Grammar with plain
% Xtext,linerange={7-53}]{../org.typesys.guidsl/src/org/typesys/guidsl/GuiDsl.xtext}

%float
\begin{lstlisting}[language=xtext,label=lst:grammar-plain,caption=Grammar with plain Xtext.] 
Model:
	(entities+=Entity | forms+=Form )*;

Form:
	"form" name=ID "edits" entity=[Entity] "{"	
		(widgets+=Widget)*
	"}";

Widget:
	TextWidget | CheckBoxWidget ;

TextWidget:
	"text" "(" length=Number ")" "->" attr=[Attribute] 
	("validate" validate=Expression)? ";";

CheckBoxWidget:
	"checkbox" "->" attr=[Attribute] ("validate" validate=Expression)? ";"
;

Entity:
	"entity" name=ID ('extends' superType=[Entity])? "{"
		(attributes+=Attribute)*
	"}";

Attribute:
	name=ID ( ((":" type=Type)? "=" expr=Expression) | 
               (":" type=Type) )";";
\end{lstlisting}

The Xtext grammar part used by all variants is shown in listing \ref{lst:grammar-plain}. The type and expressions definition part of the grammar in listing \ref{lst:grammar-plain-types-and-ex} is the same for the the plain Xtext grammar and the XSemantics and Xtext/TS grammars. The rule order reflects the precedence hierarchy of the operators, from lowest (\emph{BooleanExpression}) to highest (\emph{Atomic}). The rules use \emph{assigned actions} to produce an appropriate abstract syntax tree (cf. Xtext documentation \cite{xtextdoc}), which is used when checking types.
In the Xbase scenario, the rule \emph{Expression} is replaced with the Xbase \emph{XExpression} rule, which maps to Java types and expressions.
%float,
\begin{lstlisting}[language=xtext,label=lst:grammar-plain-types-and-ex,caption=Types and Expressions.] 
Type: PrimitiveType | EntityType;

EntityType: ref=[Entity];

PrimitiveType: NumberType | BooleanType | StringType;

NumberType: FloatType | IntType;

FloatType:   {FloatType}   "float";
IntType:     {IntType}     "int";
BooleanType: {BooleanType} "bool";
StringType:	 {StringType}  "string";

Expression: BooleanExpression;

BooleanExpression returns Expression:
       Comparison
       (({AndOrExpression.left=current} op=("||"|"&&")) right=Comparison)*;

Comparison returns Expression:
       EqualsStuff (({Comparison.left=current} op=(">="|"<="|"<"|">")
       ) right=EqualsStuff)*;

EqualsStuff returns Expression:
       Addition 
       (({Equality.left=current} op=("=="|"!=")) right=Addition)*;

Addition returns Expression:
       Multiplication (({Plus.left=current} '+' | {Minus.left=current} '-') 
        right=Multiplication)*;

Multiplication returns Expression:
       Prefixed (({MultiOrDiv.left=current} op=("*"|"/")) right=Prefixed)*;

Prefixed returns Expression:
       {BooleanNegation} =>"!" expression=Atomic | /* right associativity */
       {ArithmeticSigned} =>"-" expression=Atomic | /* right associativity */
       Atomic;

Atomic returns Expression:
       '(' Expression ')' |
       ({FieldContent} "widgetcontent") |
       ({LengthOf} "lengthOf" "(" expr=Expression ")" ) |
       ({EntityType} "new" ref=[Entity]) | 
       ({BooleanLiteral} value=("true"|"false")) |
       ({FloatLiteral} value=Float) |
       ({IntLiteral} value=INT) |
       ({StringLiteral} value=STRING) |
       ({AttributeRef} attr=[Attribute|ID]);

Float returns ecore::EBigDecimal:   INT? ('.' INT);
Number returns ecore::EBigDecimal: INT ('.' INT)?;
\end{lstlisting}

%\lstinputlisting[label=lst:grammar-plain-types-and-ex,caption=Grammar with
% plain Xtext,linerange={54-120}]{../org.typesys.guidsl/src/org/typesys/guidsl/GuiDsl.xtext}

\subsection{Demonstration Tasks}
To compare the different type system variants, each of them will show its type checking ability by demonstrating how it solves the following tasks.
\begin{enumerate}
\item Ensure that the expression after the \emph{validate} clause is boolean.
\item Show an error message when text widgets refer to boolean entity attributes.
\item Validate that checkbox widgets may only refer to boolean attributes.
\end{enumerate}

All tasks imply being able to infer the type of expressions: The \emph{validate} clause is an expression, and widgets and checkboxes may refer to derived attributes, which are defined with expressions. Test cases for the projects are online at []%TODO
