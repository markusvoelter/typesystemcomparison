\section{Case Study}

In order to compare the different approaches for type systems, the same case study is implemented using the following configuration.

\begin{itemize}
\item Plain Xtext/Xtend
\item Xtext with Xbase
\item Xtext with XSemantics
\item Xtext with Xtext/TS
\end{itemize}

\subsection{The Scenario}
In the case study, entities and forms with widgets for GUIs are modeled. The idea is to model user interfaces for manipulating entities which are, for instance, stored in a database. An entity may have simple attributes of base types like \emph{boolean}, \emph{string}, \emph{int} and \emph{float} and derived attributes with a specification on how to derive them, which may refer to other attributes. The widget of the forms are wired to attributes of the entities and may contain a \emph{validate} clause, which verifies for example the length of the input.

Listing \ref{lst:example-plain} shows an example of the DSL with a \emph{Person} entity and a \emph{PersonForm} to edit it. The attributes \emph{isAdult} and \emph{greeting} are derived. As their type can be derived, it is not specified explicitly.

%\lstinputlisting[language=bash,label=lst:example-plain,caption=Forms and
% Entities DSL,linerange={1-16}]{..//exampleCode/src/plain-xtext.gui}

\begin{lstlisting}[language=guidsl,float,label=lst:example-plain,caption=Forms
and Entities DSL] 
entity Person {
	name      : string;
	firstName : string;
	age       : int; 
	weight    : float;
	likesCake : bool; 
	/isAdult = age > 18;
	/greeting = "Hello " + firstName + " " + name;
	/testExpr = 2 - 2;
}

form PersonForm edits Person {
	text (10) -> name validate lengthOf(widgetcontent) < 10;
	text (20) -> firstName;
	text (5) -> age;
	checkbox -> isAdult validate age > 18 => widgetcontent == true;
	text(5) -> weight validate 12.5 > age;
}
\end{lstlisting}


The Xtext grammar part used by all variants is shown in listing \ref{lst:grammar-plain}. 

%\lstinputlisting[label=lst:grammar-plain,caption=Grammar with plain
% Xtext,linerange={7-53}]{../org.typesys.guidsl/src/org/typesys/guidsl/GuiDsl.xtext}

\begin{lstlisting}[language=xtext,float,label=lst:grammar-plain,caption=Grammar with plain Xtext] 
Model: (entities+=Entity | forms+=Form )*;

Entity:
	"entity" name=ID "{"
		(attributes+=Attribute)*
	"}";

Attribute: SimpleAttribute | DerivedAttribute;

DerivedAttribute: "/" name=ID "=" expr=Expression ";" ;

SimpleAttribute: name=ID ":" type=Type ";" ;

Form:
	"form" name=ID "edits" entity=[Entity] "{"	
		(widgets+=Widget)*
	"}";

Widget: TextWidget | CheckBoxWidget;

TextWidget:
	"text" "(" length=DECIMAL_NUMBER ")" 
	"->" attr=[Attribute] ("validate" validate=Expression)? ";" ;

CheckBoxWidget:
	"checkbox" "->" attr=[Attribute] ("validate" validate=Expression)? ";" ;
\end{lstlisting}

The type and expressions definition part of the grammar shown in listing \ref{lst:grammar-plain-types-and-ex}. It is the same for the the plain Xtext grammar and the XSemantics and Xtext/TS grammars. In the Xbase, the rule \emph{Expr} is replaced with the Xbase \emph{XExpression} rule, which maps Java types and expressions.

\begin{lstlisting}[language=xtext,float,label=lst:grammar-plain-types-and-ex,caption=Type and Expression grammar] 
Type: PrimitiveType | EntityType ;

EntityType: ref=[Entity];
PrimitiveType: NumberType | BooleanType | StringType;
NumberType : FloatType | IntType ;
FloatType: {FloatType} "float" ;
IntType: {IntType} "int" ;
BooleanType: {BooleanType} "bool" ;
StringType: {StringType} "string" ;

Expression: Addition;

Addition returns Expression:
	Multiplication (({Plus.left=current} '+' | {Minus.left=current} '-') right=Multiplication)*;

Multiplication returns Expression:
	Comparison (({MultiOrDiv.left=current} op=("*"|"/")) right=Comparison)*; 

Comparison returns Expression:
	BooleanExpression 
	(({Comparison.left=current} 
		op=(">="|"<="|"<"|">"|"=="|"!=")
	) right=BooleanExpression)*;

BooleanExpression returns Expression:
	Atomic (({AndOrExpression.left=current} op=("||"|"&&")) right=Atomic)*;

Atomic returns Expression:
	'(' Expression ')' |
	{BooleanNegation} =>"!" expression=Atomic | /* right associativity */
	{ArithmeticSigned} =>"-" expression=Atomic | /* right associativity */
	({FieldContent} "widgetcontent") |
	({lenghtOf} "lengthOf" "(" expr=Expression ")" ) |
	({BooleanLiteral} value=("true"|"false")) |
	({NumberLiteral} value=DECIMAL_NUMBER) |
	({StringLiteral} value=STRING) |
	({AttributeRef} attr=[Attribute|ID]) ;
\end{lstlisting}



%\lstinputlisting[label=lst:grammar-plain-types-and-ex,caption=Grammar with
% plain Xtext,linerange={54-120}]{../org.typesys.guidsl/src/org/typesys/guidsl/GuiDsl.xtext}

\subsection{Demonstration Tasks}
To compare the different type system variants, each of them will show its type checking ability by demonstrating how it solves the following tasks.
\begin{enumerate}
\item Ensure that the expression after \emph{validate} is boolean.
\item Show an error message when text widgets refer to boolean entity attributes.
\item Validate that checkbox widgets may only refer to boolean attributes.
\end{enumerate}

All tasks imply being able to infer the type of expressions: The \emph{validated} clause is an expression, and widgets and checkboxes may refer to derived attributes, which are defined with expressions. Test cases for the projects are online at []%TODO
