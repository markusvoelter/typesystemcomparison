\section{Plain Xtext}

To infer types, the plain Xtext scenario implements operations which determine the actual type of an expression, the expected type (which depends on the context where the expression is used), and operations which check whether a type is assignable to another type. The Xtext validator in listing \ref{lst:validation-plain} uses these operations. The first check operates on any expression. If the expression is in a context where a certain type is expected, helper methods are used to check whether the actual type is assignable to the expected type, for instance \emph{boolean} for the \emph{validate} clause of a widget. 
In case there is no expected type, for instance for a derived attribute, whose type is only defined by the derivation expression, the check operation just returns.

The validations operating on widgets just check whether the type of the attribute the widget refers to is \emph{boolean}.


%\input{code/GuiDslTypeProvider.xtend}%linerange={15-23,31-42,49-57}
\lstinputlisting[label=lst:validation-plain,caption=Xtext validator.,]{code/GuiDslJavaValidator.java}

\subsection{Recursive type computation}

Listing \ref{lst:plain-type-provider1} shows parts of the recursive computation of types, written in Xtend. The method \emph{getType()} determines the actual type of an expression. It avoids endless loops in case of cyclic dependencies by caching already calculated types. The type of a primitive type is defined to be the type itself. The type of an attribute is the type it refers to or the type of its initialization expression. In case there are both an initialization expression and an explicit type, a conformance check is made before. If that check fails, the default (\verb|null|) of the switch statement is returned. References to attributes have the type of the referenced attribute. %Note that \verb|e.type| is the reference to a (primitive) type while \verb|e.expr.type| and \verb|e.attr.type| recursively call \emph{getType()}. They use the Xtend 2 syntax shortcut to \verb|getType(e.expr.type)| and \verb|getType(e.attr.type)|.

\lstinputlisting[label=lst:plain-type-provider1,caption=Type provider in Xtend.]{code/GuiDslTypeProvider.xtend}

The operation \emph{getExpectedType()} in listing \ref{lst:plain-type-provider1} returns the expected type of an expression by checking its context, i.e. the container of the expression. In case of a widget the expected type is always a primitive type, so there's no need to check the context. In other cases, it calls another operation with the container of the expression and the feature of the container pointing to the expression. If the container of an expression is a \emph{Widget} and the reference was the \emph{validate} clause, the expected type is always boolean. The expected type of a subtraction, multiplication and division is a \emph{NumberType}. For an addition, it is a string, unless there is a common type of the summands that is more specific. The method returns \emph{null} to indicate if there is no expected type.

%\lstinputlisting[label=lst:plain-type-provider2,caption=Calculating the expected type.,linerange={96-98,114-146}]{../org.typesys.guidsl/src/org/typesys/guidsl/types/GuiDslTypeProvider.xtend}

\subsection{Type conformance}
An important part of type checking is whether another type can be provided where a certain type is expected.
Listing \ref{lst:plain-type-conformance} shows the Xtend code to compute whether a type is assignable to another, using polymorphic dispatch. The method \emph{isAssignable(left, right)} returns true if one can use an element of type \emph{right} where an element of type \emph{left} is expected. Polymorphic dispatch is used, so that the method with the most specific types is called. The most "general" method has the arguments \emph{(Type, Type)} and specifies that a type can always be assigned to itself, or to one of its supertypes, using the type hierarchy of the EMF model generated by the Xtext Grammar. The \emph{eClass()} method is used to get the EMF \emph{EClass} of a type for comparison (parentheses may be omitted in Xtend 2 if there is no parameter).

An entity may be assigned to an entity if its of the same type (i.e., has the same EMF \emph{EClass}), or if its a super entity. Here, the reference \emph{superType} is not an EMF reference, but the one given in the grammar for \emph{Entity}. Other special cases are dealt with the following methods. As \emph{IntType} and \emph{FloatType} are on the same EMF model inheritance hierarchy level, an assignment rule has to be explicitly specified.

\lstinputlisting[label=lst:plain-type-conformance,caption=Type conformance specification (Xtend code).]{code/TypeConformance.xtend}

\subsection{Summary}
The plain Xtext approach makes use of polymorphic dispatch and the Xtend syntax to keep the code concise, for instance with the Xtend \emph{switch} statement. It consists of four main parts:
\begin{itemize}
\item Xtend code to compute actual types recursively, written in Xtend.
\item An Xtend operation to compute expected types of expressions based on the container they are in.
\item A type conformance specification, written in Xtend.
\item The Xtext validator using the first three.
\end{itemize}

