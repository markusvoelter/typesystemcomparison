\section{Plain Xtext}
\label{sec:plain-xtext}

To infer types, the plain Xtext scenario implements operations which determine
the actual type of an expression, the expected type (which depends on the
context where the expression is used), and operations which check whether a type
is assignable to another type. The Xtext validator in listing
\ref{lst:validation-plain} uses these operations. The first check operates on
any expression. A helper method is used to check whether the actual type is assignable to the expected type, for instance \emph{boolean} for the
\emph{validate} clause of a widget. The expected type of an expression usually
depends on the context where the expression is in. In case there is no expected
type, for instance for a derived attribute, whose type is only defined by the
derivation expression, the check operation just returns. The validations
operating on widgets just check whether the type of the attribute the widget
refers to is \emph{boolean}.


%\input{code/GuiDslTypeProvider.xtend}%linerange={15-23,31-42,49-57}
\lstinputlisting[label=lst:validation-plain,caption=Xtext validator.,]{code/GuiDslJavaValidator.java}

\subsection{Recursive type computation}

Listing \ref{lst:plain-type-provider1} shows parts of the recursive computation
of types, written in Xtend. The method \emph{getType()} determines the actual
type of an expression. It avoids endless loops in case of cyclic dependencies by
caching already calculated types. The type of a primitive type model element as
well as the type of an entity is defined to be itself. The type of an attribute
is the type it refers to or the type of its initialization expression. In case
there are both an initialization expression and an explicit type, a conformance
check is made before. If that check fails, the default (\verb|null|) of the
switch statement is returned. References to attributes have the type of the
referenced attribute, and the \emph{widgetcontent} used in validate clauses has the type the widget refers to.

%Note that \verb|e.type| is the reference to a (primitive) type while \verb|e.expr.type| and \verb|e.attr.type| recursively call \emph{getType()}. They use the Xtend 2 syntax shortcut to \verb|getType(e.expr.type)| and \verb|getType(e.attr.type)|. 

\lstinputlisting[label=lst:plain-type-provider1,caption=Type provider in Xtend.]{code/GuiDslTypeProvider.xtend}

The operation \emph{getExpectedType()} in listing \ref{lst:plain-type-provider1}
returns the expected type of an EObject by checking its container. It calls another operation with the container and the feature of the container pointing to the expression. If the container of an expression is a \emph{Widget} and the feature was the \emph{validate} clause, the expected type is always boolean. If the container is a form and the 

The expected type of a subtraction, multiplication and division is a \emph{NumberType}. For an addition, it is a string, unless there
is a common type of the summands that is more specific. The method returns
\emph{null} to indicate if there is no expected type.

%\lstinputlisting[label=lst:plain-type-provider2,caption=Calculating the expected type.,linerange={96-98,114-146}]{../org.typesys.guidsl/src/org/typesys/guidsl/types/GuiDslTypeProvider.xtend}

\subsection{Type conformance}
An important part of type checking is whether another type can be provided where
a certain type is expected.
Listing \ref{lst:plain-type-conformance} shows the Xtend code to compute whether
a type is assignable to another, using polymorphic dispatch. The method
\emph{isAssignable(leftfloat, right)} returns true if one can use an element of
type \emph{right} where an element of type \emph{left} is expected. Polymorphic
dispatch is used, which means that a call to \emph{isAssignable()} will be
dispatched to the method with the most specific type parameters. The most
"general" method has the arguments \emph{(Type, Type)} and specifies that a type
can always be assigned to itself, or to one of its supertypes, using the type
hierarchy of the EMF model generated by the Xtext Grammar. The \emph{eClass()}
method is used to get the EMF \emph{EClass} of a type for comparison
(parentheses may be omitted in Xtend 2 if there is no parameter).

An entity may be assigned to an entity if it is of the same type (i.e., has the
same EMF \emph{EClass}), or if it is a super entity. Here, the reference
\emph{superType} is not an EMF reference, but the one given in the grammar for
\emph{Entity}. Other special cases are dealt with the following methods. As
\emph{IntType} and \emph{FloatType} are on the same EMF model inheritance
hierarchy level, an assignment rule has to be explicitly specified.

\lstinputlisting[label=lst:plain-type-conformance,caption=Type conformance specification (Xtend code).]{code/TypeConformance.xtend}

\subsection{Summary}
The plain Xtext approach makes use of polymorphic dispatch and the Xtend syntax
to keep the code concise, for instance with the Xtend \emph{switch} statement.
It consists of four main parts:
\begin{itemize}
\item Xtend code to compute actual types recursively,
\item an Xtend operation to compute expected types of expressions based on the container they are in,
\item a type conformance specification, also written in Xtend, and
\item the Xtext validator using the first three.
\end{itemize}

