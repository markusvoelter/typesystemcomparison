\section{Xsemantics}
\label{sec:xsemantics}

Xsemantics~\cite{lbts} (the successor of Xtypes~\cite{Bet11}) is a DSL (written
in Xtext) for writing type systems, reduction rules, interpreters (and in
general relation rules) for languages implemented in Xtext.
A system definition in Xsemantics is a set of judgment rules which have a
conclusion and a set of premises; these rules can act on any Java object,
though, typically, they will act on EObjects which are elements of the metamodel
of the language implemented in Xtext.  Indeed, Xsemantics relies on Xbase to
provide a rich syntax for defining rules (and premises of rule), thus giving
full access to Java types.

Xsemantics is thought to be used by people who are at least a little familiar
with formal type systems and operational semantics: it aims at providing
a syntax which is close to the way deduction rules are written in a formal
setting~\cite{hindley:1997a,Pierce02}.
Actually, Xsemantics rules are written in the other direction with respect
to standard deduction rules: the conclusion come before the premises; this is just
to make IDE tooling work better, and to give a more "programming" style to rules.

Starting from the definitions of these rules, Xsemantics generates Java code
that can be used in your language implemented in Xtext for scoping and
validation (it also generates a validator in Java).  Xsemantics aims at
providing a rich syntax for defining any kind of rules: relations among elements
(e.g., \emph{subtyping}), \emph{static semantics} (i.e., type systems) and
\emph{dynamic semantics} (i.e., reduction rules that can be used for
interpreting a program).  In this paper, we will use it for writing the rules of
the type system of the case study we are considering
(Section~\ref{sec:casestudy}).

\subsection{Type System Specification}

The first thing to do in a system defined in Xsemantics, after giving it a name,
is to declare the \emph{judgments} of your system; a judgment consists of

\begin{itemize}
\item 
a name, which has to be unique in the system;
\item 
a \textit{judgment symbol} that can be chosen from some predefined symbols;
\item 
the \textit{parameters} of the judgment; parameters of a judgments are separated by
	a \textit{relation symbol} that can be chosen from some predefined symbols;
\end{itemize}

\noindent
The parameters can be

\begin{itemize}
\item 
input parameters, in that case they are declared as Java parameters;
\item 
output parameters, in that case you use the keyword
\verb|output| followed by the Java
type of the output parameter.
\end{itemize}

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-judgments,caption=Judgment
definitions in Xsemantics]
system org.typesys.xsem.guidsl.xsemantics.TypeSystem

import org.typesys.xsem.guidsl.xsemGuiDsl.*

judgments {
	type ||- Typable typable : output Type
	// whether {@code right} is assignable to {@code left}
	isAssignable |- Type left <~ Type right
	// computes the most general type between {@code first} and {@code second}
	mostGeneral |- Type first ~~  Type second |> output Type
}
\end{lstlisting}

\noindent
The judgment definitions for our case study are shown in
Listing~\ref{lst:xsem-judgments}.

Once the judgments of the system are declared, we can start declaring the
rules.  Each rule consists of

\begin{itemize}
\item
a name, which has to be unique in the system;
\item
a \textit{rule conclusion};
\item
the \textit{premises} of the rule;
\end{itemize}

\noindent
The rule conclusion consists of

\begin{itemize}
\item
the name of the \textit{environment} of a rule;
\item
a \textit{judgment symbol};
\item
the \textit{parameters} of the rules, which are separated by
a \textit{relation symbol} that can be chosen from some predefined symbols;
\end{itemize}

The things that make a rule belong to a specific judgment are the judgment
symbol and the relation symbols (which separate the parameters); moreover the
types of the parameters of a rule must be (Java) subtypes of the corresponding types
of the judgment (or exactly the same Java types).  Two rules belonging to the
same judgment must differ for at least one input parameter's type.

The premises of a rule which are specified in a \verb|from| block can be any
Xbase expression, or a rule invocation.  If you think of a rule declaration as a
function declaration, then a rule invocation corresponds to function invocation,
thus you must specify the environment to pass to the rule, and the arguments,
both input and output arguments.
The premises of an Xsemantics rule are considered in \emph{logical and} relation
and are verified in the same order they are specified in the block.
If we need premises (block of premises) in \emph{logical or} relation, we can
use the operator \verb|or|, which separates blocks of premises; if (and only if) one
of the premises of the first block fails, the premises of the second block are
inspected, etc.

Also the concept of rule environment is taken from the type theory (usually is
denoted by the $\g$).  It can be used to pass additional argument to rules.
If you want to be sure to pass an empty environment when invoking a rule you can
use the keyword \mykeyb{empty}.
Furthermore, when passing an environment during a rule invocation, one
can specify additional \emph{environment mapping}, using the syntax
\lstinline[breakatwhitespace=false,breaklines=true]!key <- value!, 
where you can use any Xbase expression;
you can also pass an environment with additional
mappings separated by a comma (or even build an environment from scratch
by specifyin all the mappings, still separated by a comma); for instance
\lstinline[breakatwhitespace=false,breaklines=true]!G, x <- 'foo', y <- 10! 
or
\lstinline[breakatwhitespace=false,breaklines=true]!x <- o.eClass, y <- (o.eClass.name == 'foo')!, 
etc.
Note that when you pass an environment to a rule with additional mappings,
you actually pass a brand new environment, thus you will not modify the
current rule environment; if a mapping already exists in the current rule
environment, in the brand new environment (and only there) the existing mapping
will be overwritten.  Thus, the rule environment passed to a rule acts
in a stack manner.

If a rule does not require any premise, we can use a special form of
rules, called indeed \textit{axiom}s, which only have a conclusion, without
premises.
In the premises you can assign values to the output parameters; and when you
invoke another rule, upon return, the output arguments will have the values
assigned in the invoked rule.

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-firstrules,caption=Some
examples of rules and axioms in Xsemantics.]
axiom BooleanLiteralType
	G |- BooleanLiteral lit : XsemGuiDslFactory::eINSTANCE.createBooleanType

rule AttributeRefType
	G |- AttributeRef attrRef : Type type
from {
	G |- attrRef.attr : type
}

rule LengthOfType
	G |- LenghtOf len : XsemGuiDslFactory::eINSTANCE.createIntType
from {
	G |- len.expr : var StringType stringType
}

rule FieldContentType
	G |- FieldContent fieldContent : Type type
from {
	G |- env(G, 'widgetcontent', Attribute) : type
}
\end{lstlisting}

In Listing~\ref{lst:xsem-firstrules} we present some rules for the judgment
\mytt{type} (see Listing~\ref{lst:xsem-judgments}, recall that in the rules of
these judgments the second parameter is an output parameter).
For typing a literal (in the example a boolean literal) we write an axiom (since
there is no premise) and the result is a \mytt{BooleanType} (created through the
EMF factory for our language).  The rule for typing an \mytt{AttributeRef} can
be read as follows: the type of an \mytt{AttributeRef} is the type resulting
from typing the corresponding referred attribute (the feature \mytt{attr}, refer
to Listing~\ref{lst:grammar-plain}). The type of a \mytt{LenghtOf} expression is
an integer type, provided that the expression argument of \mytt{LenghtOf} has
string type.  Finally, for typing \mykeyb{widgetcontent} we make use of the
rule environment: we access the environment with the predefined function
\mykeyb{env}, by specifying the key and the expected Java type of the
corresponding value.  If no key is found in the environment or the value cannot
be assigned to the specified Java type the premise will fail.  We will show
how such environment is passed in Section~\ref{sec:xsem-validation}.  Thus, this
rule will type \mykeyb{widgetcontent} with the type of the corresponding
attribute. 

In an hypothetic formal type system, we would probably write these typing rules

\begin{center}
\begin{tabular}{c@{\hspace{.5cm}}c@{\hspace{.5cm}}c}
\inferrule
{}
{\g \f \mykeyb{true} : \mykeyb{boolean} }
&
\inferrule
{\g \f \mytt{attr} : \T}
{\g \f \mykeyb{ref} \ \mytt{attr} : \T }
\\
\\
\inferrule
{\g \f \mytt{exp} : \mykeyb{string}}
{\g \f \mykeyb{lengthOf}(\mytt{exp}) : \mykeyb{int} }
&
\inferrule
{\g \f \g(\mykeyb{widgetcontent}) : \T}
{\g \f \mykeyb{widgetcontent} : \T }
\end{tabular}
\end{center}

\noindent
Note how, the rules in Xsemantics (see Listing~\ref{lst:xsem-firstrules}) remind
of the deduction rules typically used in formal type systems.

At runtime, upon rule invocation, the generated Java system will select the most
appropriate rule according to the runtime types of the passed argument (using
the \textit{polymorphic dispatch} mechanism provided by Xtext).

If one of the premises fails, then the whole rule will fail, and in turn all the
stack of rule invocation will fail.  In particular, if the premise is a boolean
expression, it will fail if the expression evaluates to false.  If the premise
is a rule invocation, it will fail if the invoked rule fails.

As another example, we show in Listing~\ref{lst:xsem-attribute} the rule for
\mytt{Attribute}.  Recall (refer to Listing~\ref{lst:grammar-plain}) that an
attribute can have an explicit type and an initialization expression. The rule
says that in case the type is not explicit the resulting type is the type of the
initialization expression; otherwise, the resulting type is the explicit type of
the attribute; however, in the latter case, if the initialization expression is
specified, then we must make sure that the type of the expression is assignable
to the declared type.

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-attribute,caption=Type
rule for \mytt{Attribute}.] 
rule AttributeType 
	G |- Attribute attr : Type attrType 
from {
	if (attr.type != null) {
		if (attr.expr != null) {
			G |- attr.expr : var Type expType
			G |- attr.type <~ expType
		}
		attrType = attr.type
	} else {
		G |- attr.expr : attrType
	}
}
\end{lstlisting}

Thus, the rule in Listing~\ref{lst:xsem-attribute} relies on rules of the
judgment \mytt{isAssignable} (see Listing~\ref{lst:xsem-judgments}); the rules
of this judgment, which basically implements subtyping, do not have an output
parameter, they accept two types as parameters; the intention of these rules is
that they succeed if the right parameter is assignable to the left parameter.

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-assignable,caption=Some
rules for the \mytt{isAssignable} judgment.] 
rule IsAssignableBase
	G |- Type left <~ Type right
from {
	left.eClass == right.eClass
}

axiom BooleanAssignableToString
	G |- StringType left <~ BooleanType right

axiom IntAssignableToString
	G |- StringType left <~ NumberType right

axiom IntAssignableToFloat
	G |- FloatType left <~ IntType right
\end{lstlisting}

In Listing~\ref{lst:xsem-assignable} we present some rules for the
\mytt{isAssignable} judgment.  The first rule is the most general case, and says
that types of the same kind are assignable to each other (in this context
``kind'' corresponds to EClass); moreover, we have some axioms saying that
booleans and integers are assignable to strings (for instance, like in Java, by
an implicit conversion through \mytt{toString} method).  Finally, an integer can
be assigned to a float.

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-entitysubtyping,caption=Rule
for \mytt{isAssignable} for entity types.] 
rule EntityTypeAssignable
	G |- EntityType left <~ EntityType right
from {
	left.ref == right.ref
	or
	getAll(right.ref, 
		XsemGuiDslPackage::eINSTANCE.entity_SuperType,
		XsemGuiDslPackage::eINSTANCE.entity_SuperType,
		typeof(Entity)
	).contains(left.ref)
}
\end{lstlisting}

In Listing~\ref{lst:xsem-entitysubtyping} we show a more interesting case for
subtyping: the one between two \mytt{EntityType}.  The idea is that \mytt{right}
can be assigned to \mytt{left} either if they are the same type (entity
subtyping is reflexive) or if \mytt{left} is a ``super entity'' (possibly
indirectly) for \mytt{right} (entity subtyping is transitive).  We could check
the latter condition by following recursively the feature \mytt{superType} of
the right entity; however, in an uncorrect program the entity hierarchy might be
acyclic, and this recursive inspection might lead to an infinite loop.  In a
manual Java implementation we thus would have to keep track of the visited
entities while inspecting the hierarchy (see
Listing~\ref{lst:plain-type-conformance}).  Indeed, the AST for Xtext languages,
due to references might be graphs.  Since when developing Xtext languages we
might face the issue of inspecting a graph avoiding possible loops, e.g., to
compute the ``closure'' of a graph, Xsemantics provides a predefined function
which allows to collect nodes in a graph according to EMF features avoiding
loops.  Such function is

\begin{small}
\begin{verbatim}
getAll(eObject, feature to collect, feature to follow, expected type)
\end{verbatim}
\end{small}

\noindent an invocation of \mytt{getAll} will return a list of ``expected
type'', built by collecting all the elements from ``feature to collect'' of the
specified ``eObject'', and recursively collecting such elements by following the
feature ``feature to collect'', but avoiding possible loops in the EMF graph
representing the AST.
Thus, in the use of Listing~\ref{lst:xsem-entitysubtyping}, it will return all
the superclasses of \mytt{right}.  Similarly, we can get all the attributes of
an entity, including the inherited ones, by simply calling

\begin{lstlisting}[language=xsemantics] 
	getAll(entity, 
		XsemGuiDslPackage::eINSTANCE.entity_Attribute,
		XsemGuiDslPackage::eINSTANCE.entity_SuperType,
		typeof(Attribute))
\end{lstlisting}

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-mostgeneral,caption=Rule
for \mytt{mostGeneral}.] 
rule MostGeneral
	G |- Type first ~~ Type second |> Type mostGeneral
from {
	{
		G |- first <~ second
		mostGeneral = first
	} or
		mostGeneral = second
}
\end{lstlisting}

The judgment \mytt{mostGeneral} (Listing~\ref{lst:xsem-judgments}) takes two
types as input parameters and returns as output the most general between the
two; this judgment has one simple rule, shown in
Listing~\ref{lst:xsem-mostgeneral}.

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-binaryexp,caption=Some
rules for binary expressions.] 
rule MinusType
	G |- Minus minus : NumberType type
from {
	// require number types
	G |- minus.left : var NumberType leftType
	G |- minus.right : var NumberType rightType
	// get the most general
	G |- leftType ~~ rightType |> type
}

rule PlusType
	G |- Plus plus : Type type
from {
	// deal with any type
	G |- plus.left : var Type leftType
	G |- plus.right : var Type rightType
	// get the most general (which can also be string)
	G |- leftType ~~ rightType |> type
}
\end{lstlisting}

The judgment \mytt{mostGeneral} is useful for typing some binary expressions,
for instance, \mytt{Minus} and \mytt{Plus}, shown in
Listing~\ref{lst:xsem-binaryexp}.  The typing rule for \mytt{Minus} requires
that the two subexpressions have a numeric type (recall that since we specify a
\mytt{NumberType} as the output argument in rule invocation, such invocation
will succeed only if the result is assignable to \mytt{NumberType}); the
resulting type will be the most general type, thus, for instance, if one of the
two subexpressions have type \mytt{FloatType} and the other one \mytt{IntType},
the resulting type will be \mytt{FloatType}.  Recall that we use \mytt{+} not
only as the arithmetic operator, but also for string concatenation; in
particular, if one of the subexpression is a string, the whole expression is
considered as string concatenation.  Thus, the rule for \mytt{Plus} computes the
types of the two subexpressions, and then gets the most general; if one of them
is a string type, the whole expression will have string type (see also subtyping
rules in Listing~\ref{lst:xsem-assignable}).

\subsection{Rules for the Validator}
\label{sec:xsem-validation}

In an Xsemantics we can specify some special rules which do not belong to any
judgment, \mytt{checkrule}, which are used by Xsemantics to generate a Java
validator for the Xtext language.  A \mytt{checkrule} has a name, a single
parameter (which is the EObject which will be checked by the validator) and the
premises (but no rule environment).  The syntax of the premises of a
\mytt{checkrule} is the same of standard rules.
Xsemantics will generate a Java validator with a \checkm{} method for each
\mytt{checkrule}; just like in Java validators for Xtext languages, you can have
many checkrules for the same JavaType (provided the rule name is unique).

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-validator,caption=Some
checkrules for the Validator.] 
checkrule AttributeTypeChecks for Attribute attribute
from { empty |- attribute : var Type type }

checkrule ValidateMustBeBoolean for Widget widget
from {
	widget.validate == null
	or 
	'widgetcontent' <- widget.attr |- widget.validate : var BooleanType boolType
}

checkrule ValidateTextWidgetAttributeNotBoolean for TextWidget widget
from {
	'widgetcontent' <- widget.attr |- widget.attr : var Type attrType
	!(attrType instanceof BooleanType)
}

checkrule ValidateCheckBoxWidgetAttributeBoolean for CheckBoxWidget widget
from { 'widgetcontent' <- widget.attr |- widget.attr : var BooleanType attrType }
\end{lstlisting}

In Listing~\ref{lst:xsem-validator} we present some checkrules for validating
the elements of our language (see Section~\ref{sec:casestudy}).  The first
checkrule basically says that an Attribute is correct if we can give it a type
(in the empty environment).  The second one accepts a Widget provided that
either its validate part is not specified or it has a boolean type; note that in
this case we pass to the type judgment an explicit environment so that we are
able to type possible occurrences of \mykeyb{widgetcontent}.  These first two
rules also show an important use of environment: since the rule for typing
\mykeyb{widgetcontent} requires that the string `widgetcontent' is bound to an
attribute in the environment, and since when typing an attribute we provide an
empty environment, then a possible occurrence of \mykeyb{widgetcontent} in an
attribute's initialization expression (which is accepted by the grammar) will be
automatically (and correctly) rejected.
The third checkrule requires that the text widget's attribute is not of boolean
type, while the fourth one requires that the checkbox's attribute has a boolean
type (by implicitly trying to assing the result type, in the rule invocation, to
a boolean type).
\subsection{Usage in Xtext}

Xsemantics will generate two Java classes for each xsemantics system:
A Java class with the same name of the system, containing all the
implementations of the system's rules; a derived class from
\mytt{AbstractDeclarativeValidator}, with a \checkm{} for each checkrule (see
Section~\ref{sec:xsem-validation}).
The generated classes rely on Google injection, and they delegate some jobs to
other classes that the programmer can inject to customize the behavior of the
generated code.

The generated validator can be used in conjunction with the language existing
Java validator (so that some checks can be implemented manually and the other
ones rely on the code generated by Xsemantics).  The other Java class,
representing the system written in Xsemantics can be used in all the other parts
of the Xtext implementation of the DSL.  A typical use is in the scope provider,
in languages where the scope of elements highly rely on types, for instance.

The generated Java class containing the rules of your system will have
public methods for the judgments of your system.  For instance, if a judgment is
defined as follows


\begin{lstlisting}[language=xsemantics] 
judgments {
	myjudgment |- MyClass1 arg1 : MyClass2 arg2 : output MyOutputClass
}
\end{lstlisting}

\noindent
the generated Java system will feature three public methods

\begin{lstlisting}[language=Java] 
public Result<MyOutputClass> myjudgment(MyClass1 arg1, MyClass2 arg2)
public Result<MyOutputClass> myjudgment(RuleEnvironment env,
	MyClass1 arg1, MyClass2 arg2)
public Result<MyOutputClass> myjudgment(
	RuleEnvironment env, RuleApplication trace,
	MyClass1 arg1, MyClass2 arg2)
\end{lstlisting}

The class \mytt{Result} is part of Xsemantics runtime, and it is a wrapper for
the actual result value and a possible failure (in the shape of a \failedexc.
The value in the result will be \mytt{null} if the judgment rule failed; in that
case one might want to inspect the \failedexc.
In particular, Xsemantics provides utility methods to get the stack of all the
rule failures (also already formatted as an indented string).
In case the judgment has two output parameters, the class
\mytt{Result2} will be used which acts as a pair.
If the judgment has no output parameter, the type of the result will
be \mytt{Result<Boolean>}.

The first generated method basically only takes the arguments specified in the
judgment.  With the second version, you can also pass an environment
(generated Java code can transparently deal with null environments).
The third one is useful for testing/debugging purposes: if you pass
an instance of \ruleapptrace{} if the
method terminates with success you can then inspect the trace of all the rules
invoked together with the values used in the rules.  If the judgment fails,
you will see also the rules that failed in the rule application trace.
Xsemantics provides utility methods to get a string representation of a trace
indented, with the following idea

\begin{footnotesize}
\begin{verbatim}
final result provided by rule MyRule
 rule 1 used by MyRule to get to the result
  rule 2 used by rule 1
   rule 3 used by rule 2
   ...
 rule 1a used by MyRule to get to the result
  rule 2a used by rule 1a
  ...
\end{verbatim}
\end{footnotesize}
