\section{Xsemantics}
\label{sec:xsemantics}

Xsemantics~\cite{lbts} (the successor of Xtypes~\cite{Bet11}) is a DSL (written
in Xtext) for writing type systems, reduction rules, interpreters (and in
general relation rules) for languages implemented in Xtext.
A system definition in Xsemantics is a set of judgment rules which have a
conclusion and a set of premises; these rules can act on any Java object,
though, typically, they will act on EObjects which are elements of the metamodel
of the language implemented in Xtext.  Indeed, Xsemantics relies on Xbase to
provide a rich syntax for defining rules (and premises of rule), thus giving
full access to Java types.

Xsemantics is thought to be used by people who are at least a little familiar
with formal type systems and operational semantics: it aims at providing
a syntax which is close to the way deduction rules are written in a formal
setting~\cite{hindley:1997a,Pierce02}.
Actually, Xsemantics rules are written in the other direction with respect
to standard deduction rules: the conclusion come before the premises; this is just
to make IDE tooling work better, and to give a more "programming" style to rules.

Starting from the definitions of these rules, Xsemantics generates Java code
that can be used in your language implemented in Xtext for scoping and
validation (it also generates a validator in Java).  Xsemantics aims at
providing a rich syntax for defining any kind of rules: relations among elements
(e.g., \emph{subtyping}), \emph{static semantics} (i.e., type systems) and
\emph{dynamic semantics} (i.e., reduction rules that can be used for
interpreting a program).  In this paper, we will use it for writing the rules of
the type system of the case study we are considering
(Section~\ref{sec:casestudy}).

\subsection{Type System Specification}

The first thing to do in a system defined in Xsemantics, after giving it a name,
is to declare the \emph{judgments} of your system; a judgment consists of

\begin{itemize}
\item 
a name, which has to be unique in the system;
\item 
a \textit{judgment symbol} that can be chosen from some predefined symbols;
\item 
the \textit{parameters} of the judgment; parameters of a judgments are separated by
	a \textit{relation symbol} that can be chosen from some predefined symbols;
\end{itemize}

\noindent
The parameters can be

\begin{itemize}
\item 
input parameters, in that case they are declared as Java parameters;
\item 
output parameters, in that case you use the keyword
\verb|output| followed by the Java
type of the output parameter.
\end{itemize}

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-judgments,caption=Judgment
definitions in Xsemantics]
system org.typesys.xsem.guidsl.xsemantics.TypeSystem

import org.typesys.xsem.guidsl.xsemGuiDsl.*

judgments {
	type ||- Typable typable : output Type
	// whether {@code right} is assignable to {@code left}
	isAssignable |- Type left <~ Type right
	// computes the most general type between {@code first} and {@code second}
	mostGeneral |- Type first ~~  Type second |> output Type
}
\end{lstlisting}

\noindent
The judgment definitions for our case study are shown in
Listing~\ref{lst:xsem-judgments}.

Once the judgments of the system are declared, we can start declaring the
rules.  Each rule consists of

\begin{itemize}
\item
a name, which has to be unique in the system;
\item
a \textit{rule conclusion};
\item
the \textit{premises} of the rule;
\end{itemize}

\noindent
The rule conclusion consists of

\begin{itemize}
\item
the name of the \textit{environment} of a rule;
\item
a \textit{judgment symbol};
\item
the \textit{parameters} of the rules, which are separated by
a \textit{relation symbol} that can be chosen from some predefined symbols;
\end{itemize}

The things that make a rule belong to a specific judgment are the judgment
symbol and the relation symbols (which separate the parameters); moreover the
types of the parameters of a rule must be (Java) subtypes of the corresponding types
of the judgment (or exactly the same Java types).  Two rules belonging to the
same judgment must differ for at least one input parameter's type.

The premises of a rule which are specified in a \verb|from| block can be any
Xbase expression, or a rule invocation.  If you think of a rule declaration as a
function declaration, then a rule invocation corresponds to function invocation,
thus you must specify the environment to pass to the rule, and the arguments,
both input and output arguments.
Moreover, if a rule does not require any premise, we can use a special form of
rules, called indeed \textit{axiom}s, which only have a conclusion, without
premises.
In the premises you can assign values to the output parameters; and when you
invoke another rule, upon return, the output arguments will have the values
assigned in the invoked rule.

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-firstrules,caption=Some
examples of rules and axioms in Xsemantics.]
axiom BooleanLiteralType
	G |- BooleanLiteral lit : XsemGuiDslFactory::eINSTANCE.createBooleanType

rule AttributeRefType
	G |- AttributeRef attrRef : Type type
from {
	G |- attrRef.attr : type
}

rule LengthOfType
	G |- LenghtOf len : XsemGuiDslFactory::eINSTANCE.createIntType
from {
	G |- len.expr : var StringType stringType
}
\end{lstlisting}

In Listing~\ref{lst:xsem-firstrules} we present some rules for the judgment
\mytt{type} (see Listing~\ref{lst:xsem-judgments}, recall that in the rules of
these judgments the second parameter is an output parameter).
For typing a literal (in the example a boolean literal) we write an axiom (since
there is no premise) and the result is a \mytt{BooleanType} (created through the
EMF factory for our language).  The rule for typing an \mytt{AttributeRef} can
be read as follows: the type of an \mytt{AttributeRef} is the type resulting
from typing the corresponding referred attribute (the feature \mytt{attr}, refer
to Listing~\ref{lst:grammar-plain}). The type of a \mytt{LenghtOf} expression is
an integer type, provided that the expression argument of \mytt{LenghtOf} has
string type.

In an hypothetic formal type system, we would probably write these typing rules

\begin{tabular}{c@{\hspace{.5cm}}c@{\hspace{.5cm}}c}
\inferrule
{}
{\g \f \mykeyb{true} : \mykeyb{boolean} }
&
\inferrule
{\g \f \mytt{attr} : \T}
{\g \f \mykeyb{ref} \ \mytt{attr} : \T }
&
\inferrule
{\g \f \mytt{exp} : \mykeyb{string}}
{\g \f \mykeyb{lengthOf}(\mytt{exp}) : \mykeyb{int} }
\end{tabular}

\noindent
Note how, the rules in Xsemantics remind the deduction rules typically used in
formal type systems (see Listing~\ref{lst:xsem-firstrules}).

At runtime, upon rule invocation, the generated Java system will select the most
appropriate rule according to the runtime types of the passed argument (using
the \textit{polymorphic dispatch} mechanism provided by Xtext).

If one of the premises fails, then the whole rule will fail, and in turn all the
stack of rule invocation will fail.  In particular, if the premise is a boolean
expression, it will fail if the expression evaluates to false.  If the premise
is a rule invocation, it will fail if the invoked rule fails.

As another example, we show in Listing~\ref{lst:xsem-attribute} the rule for
\mytt{Attribute}.  Recall (refer to Listing~\ref{lst:grammar-plain}) that an
attribute can have an explicit type and an initialization expression. The rule
says that in case the type is not explicit the resulting type is the type of the
initialization expression; otherwise, the resulting type is the explicit type of
the attribute; however, in the latter case, if the initialization expression is
specified, then we must make sure that the type of the expression is assignable
to the declared type.

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-attribute,caption=Type
rule for \mytt{Attribute}.] 
rule AttributeType 
	G |- Attribute attr : Type attrType 
from {
	if (attr.type != null) {
		if (attr.expr != null) {
			G |- attr.expr : var Type expType
			G |- attr.type <~ expType
		}
		attrType = attr.type
	} else {
		G |- attr.expr : attrType
	}
}
\end{lstlisting}

Thus, the rule in Listing~\ref{lst:xsem-attribute} relies on rules of the
judgment \mytt{isAssignable} (see Listing~\ref{lst:xsem-judgments}); the rules
of this judgment do not have an output parameter, they accept two types as
parameters; the intention of these rules is that they succeed if the right
parameter is assignable to the left parameter.

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-assignable,caption=Some
rules for the \mytt{isAssignable} judgment.] 
rule IsAssignableBase
	G |- Type left <~ Type right
from {
	left.eClass == right.eClass
}

axiom BooleanAssignableToString
	G |- StringType left <~ BooleanType right

axiom IntAssignableToString
	G |- StringType left <~ NumberType right

axiom IntAssignableToFloat
	G |- FloatType left <~ IntType right
\end{lstlisting}

In Listing~\ref{lst:xsem-assignable} we present some rules for the
\mytt{isAssignable} judgment.  The first rule is the most general case, and says
that types of the same kind are assignable to each other (in this context
``kind'' corresponds to EClass); moreover, we have some axioms saying that
booleans and integers are assignable to strings (for instance, like in Java, by
an implicit conversion through \mytt{toString} method).  Finally, an integer can
be assigned to a float.

\subsection{Usage in Xtext}

With the declarative specification (written in the Xsemantics DSL), Java methods are generated that can be used in the SopeProvider or Validators. 

If the declarative rules are marked with [â€¦], Xtext validator classes are directly created and no further work is necessary.

Example output for reusable methods

\begin{lstlisting}
TypeSystemResult<MyOtherGrammarElement> typeAsMyOtherGrammarElement(MyGrammarElement left); 
TypeSystemResult<MyGrammarElement, MyOtherGrammarElement> type(MyGrammarElement left, MyOtherGrammarElement right); 
TypeSystemResult<Boolean> checkType(MyGrammarElement left, MyOtherGrammarElement right); 
\end{lstlisting}
