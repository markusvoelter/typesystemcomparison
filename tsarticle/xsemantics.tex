\section{Xsemantics}
\label{sec:xsemantics}

Xsemantics~\cite{lbts} (the successor of Xtypes~\cite{Bet11}) is a DSL (written
in Xtext) for writing type systems, reduction rules, interpreters (and in
general relation rules) for languages implemented in Xtext.
A system definition in Xsemantics is a set of judgment rules which have a
conclusion and a set of premises; these rules can act on any Java object,
though, typically, they will act on EObjects which are elements of the metamodel
of the language implemented in Xtext.  Indeed, Xsemantics relies on Xbase to
provide a rich syntax for defining rules (and premises of rule), thus giving
full access to Java types.

Xsemantics is thought to be used by people who are at least a little familiar
with formal type systems and operational semantics: it aims at providing
a syntax which is close to the way deduction rules are written in a formal
setting~\cite{hindley:1997a,Pierce02}.
Actually, Xsemantics rules are written in the other direction with respect
to standard deduction rules: the conclusion come before the premises; this is just
to make IDE tooling work better, and to give a more "programming" style to rules.

Starting from the definitions of these rules, Xsemantics generates Java code
that can be used in your language implemented in Xtext for scoping and
validation (it also generates a validator in Java).  Xsemantics aims at
providing a rich syntax for defining any kind of rules: relations among elements
(e.g., \emph{subtyping}), \emph{static semantics} (i.e., type systems) and
\emph{dynamic semantics} (i.e., reduction rules that can be used for
interpreting a program).  In this paper, we will use it for writing the rules of
the type system of the case study we are considering
(Section~\ref{sec:casestudy}).

\subsection{Type System Specification}

The first thing to do in a system defined in Xsemantics, after giving it a name,
is to declare the \emph{judgments} of your system; a judgment consists of

\begin{itemize}
\item 
a name, which has to be unique in the system;
\item 
a \textit{judgment symbol} that can be chosen from some predefined symbols;
\item 
the \textit{parameters} of the judgment; parameters of a judgments are separated by
	a \textit{relation symbol} that can be chosen from some predefined symbols;
\end{itemize}

\noindent
The parameters can be

\begin{itemize}
\item 
input parameters, in that case they are declared as Java parameters;
\item 
output parameters, in that case you use the keyword
\verb|output| followed by the Java
type of the output parameter.
\end{itemize}

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-judgments,caption=Judgment
definitions in Xsemantics]
system org.typesys.xsem.guidsl.xsemantics.TypeSystem

import org.typesys.xsem.guidsl.xsemGuiDsl.*

judgments {
	type ||- Typable typable : output Type
	// whether {@code right} is assignable to {@code left}
	isAssignable |- Type left <~ Type right
	// computes the most general type between {@code first} and {@code second}
	mostGeneral |- Type first ~~  Type second |> output Type
}
\end{lstlisting}

\noindent
The judgment definitions for our case study are shown in
Listing~\ref{lst:xsem-judgments}.

Once the judgments of the system are declared, we can start declaring the
rules.  Each rule consists of

\begin{itemize}
\item
a name, which has to be unique in the system;
\item
a \textit{rule conclusion};
\item
the \textit{premises} of the rule;
\end{itemize}

\noindent
The rule conclusion consists of

\begin{itemize}
\item
the name of the \textit{environment} of a rule;
\item
a \textit{judgment symbol};
\item
the \textit{parameters} of the rules, which are separated by
a \textit{relation symbol} that can be chosen from some predefined symbols;
\end{itemize}

The things that make a rule belong to a specific judgment are the judgment
symbol and the relation symbols (which separate the parameters); moreover the
types of the parameters of a rule must be (Java) subtypes of the corresponding types
of the judgment (or exactly the same Java types).  Two rules belonging to the
same judgment must differ for at least one input parameter's type.

The premises of a rule which are specified in a \verb|from| block can be any
Xbase expression, or a rule invocation.  If you think of a rule declaration as a
function declaration, then a rule invocation corresponds to function invocation,
thus you must specify the environment to pass to the rule, and the arguments,
both input and output arguments.
The premises of an Xsemantics rule are considered in \emph{logical and} relation
and are verified in the same order they are specified in the block.
If we need premises (block of premises) in \emph{logical or} relation, we can
use the operator \verb|or|, which separates blocks of premises; if (and only if) one
of the premises of the first block fails, the premises of the second block are
inspected, etc.

If a rule does not require any premise, we can use a special form of
rules, called indeed \textit{axiom}s, which only have a conclusion, without
premises.
In the premises you can assign values to the output parameters; and when you
invoke another rule, upon return, the output arguments will have the values
assigned in the invoked rule.

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-firstrules,caption=Some
examples of rules and axioms in Xsemantics.]
axiom BooleanLiteralType
	G |- BooleanLiteral lit : XsemGuiDslFactory::eINSTANCE.createBooleanType

rule AttributeRefType
	G |- AttributeRef attrRef : Type type
from {
	G |- attrRef.attr : type
}

rule LengthOfType
	G |- LenghtOf len : XsemGuiDslFactory::eINSTANCE.createIntType
from {
	G |- len.expr : var StringType stringType
}
\end{lstlisting}

In Listing~\ref{lst:xsem-firstrules} we present some rules for the judgment
\mytt{type} (see Listing~\ref{lst:xsem-judgments}, recall that in the rules of
these judgments the second parameter is an output parameter).
For typing a literal (in the example a boolean literal) we write an axiom (since
there is no premise) and the result is a \mytt{BooleanType} (created through the
EMF factory for our language).  The rule for typing an \mytt{AttributeRef} can
be read as follows: the type of an \mytt{AttributeRef} is the type resulting
from typing the corresponding referred attribute (the feature \mytt{attr}, refer
to Listing~\ref{lst:grammar-plain}). The type of a \mytt{LenghtOf} expression is
an integer type, provided that the expression argument of \mytt{LenghtOf} has
string type.

In an hypothetic formal type system, we would probably write these typing rules

\begin{tabular}{c@{\hspace{.5cm}}c@{\hspace{.5cm}}c}
\inferrule
{}
{\g \f \mykeyb{true} : \mykeyb{boolean} }
&
\inferrule
{\g \f \mytt{attr} : \T}
{\g \f \mykeyb{ref} \ \mytt{attr} : \T }
&
\inferrule
{\g \f \mytt{exp} : \mykeyb{string}}
{\g \f \mykeyb{lengthOf}(\mytt{exp}) : \mykeyb{int} }
\end{tabular}

\noindent
Note how, the rules in Xsemantics remind the deduction rules typically used in
formal type systems (see Listing~\ref{lst:xsem-firstrules}).

At runtime, upon rule invocation, the generated Java system will select the most
appropriate rule according to the runtime types of the passed argument (using
the \textit{polymorphic dispatch} mechanism provided by Xtext).

If one of the premises fails, then the whole rule will fail, and in turn all the
stack of rule invocation will fail.  In particular, if the premise is a boolean
expression, it will fail if the expression evaluates to false.  If the premise
is a rule invocation, it will fail if the invoked rule fails.

As another example, we show in Listing~\ref{lst:xsem-attribute} the rule for
\mytt{Attribute}.  Recall (refer to Listing~\ref{lst:grammar-plain}) that an
attribute can have an explicit type and an initialization expression. The rule
says that in case the type is not explicit the resulting type is the type of the
initialization expression; otherwise, the resulting type is the explicit type of
the attribute; however, in the latter case, if the initialization expression is
specified, then we must make sure that the type of the expression is assignable
to the declared type.

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-attribute,caption=Type
rule for \mytt{Attribute}.] 
rule AttributeType 
	G |- Attribute attr : Type attrType 
from {
	if (attr.type != null) {
		if (attr.expr != null) {
			G |- attr.expr : var Type expType
			G |- attr.type <~ expType
		}
		attrType = attr.type
	} else {
		G |- attr.expr : attrType
	}
}
\end{lstlisting}

Thus, the rule in Listing~\ref{lst:xsem-attribute} relies on rules of the
judgment \mytt{isAssignable} (see Listing~\ref{lst:xsem-judgments}); the rules
of this judgment, which basically implements subtyping, do not have an output
parameter, they accept two types as parameters; the intention of these rules is
that they succeed if the right parameter is assignable to the left parameter.

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-assignable,caption=Some
rules for the \mytt{isAssignable} judgment.] 
rule IsAssignableBase
	G |- Type left <~ Type right
from {
	left.eClass == right.eClass
}

axiom BooleanAssignableToString
	G |- StringType left <~ BooleanType right

axiom IntAssignableToString
	G |- StringType left <~ NumberType right

axiom IntAssignableToFloat
	G |- FloatType left <~ IntType right
\end{lstlisting}

In Listing~\ref{lst:xsem-assignable} we present some rules for the
\mytt{isAssignable} judgment.  The first rule is the most general case, and says
that types of the same kind are assignable to each other (in this context
``kind'' corresponds to EClass); moreover, we have some axioms saying that
booleans and integers are assignable to strings (for instance, like in Java, by
an implicit conversion through \mytt{toString} method).  Finally, an integer can
be assigned to a float.

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-entitysubtyping,caption=Rule
for \mytt{isAssignable} for entity types.] 
rule EntityTypeAssignable
	G |- EntityType left <~ EntityType right
from {
	left.ref == right.ref
	or
	getAll(right.ref, 
		XsemGuiDslPackage::eINSTANCE.entity_SuperType,
		XsemGuiDslPackage::eINSTANCE.entity_SuperType,
		typeof(Entity)
	).contains(left.ref)
}
\end{lstlisting}

In Listing~\ref{lst:xsem-entitysubtyping} we show a more interesting case for
subtyping: the one between two \mytt{EntityType}.  The idea is that \mytt{right}
can be assigned to \mytt{left} either if they are the same type (entity
subtyping is reflexive) or if \mytt{left} is a ``super entity'' (possibly
indirectly) for \mytt{right} (entity subtyping is transitive).  We could check
the latter condition by following recursively the feature \mytt{superType} of
the right entity; however, in an uncorrect program the entity hierarchy might be
acyclic, and this recursive inspection might lead to an infinite loop.  In a
manual Java implementation we thus would have to keep track of the visited
entities while inspecting the hierarchy (see
Listing~\ref{lst:plain-type-conformance}).  Indeed, the AST for Xtext languages,
due to references might be graphs.  Since when developing Xtext languages we
might face the issue of inspecting a graph avoiding possible loops, e.g., to
compute the ``closure'' of a graph, Xsemantics provides a predefined function
which allows to collect nodes in a graph according to EMF features avoiding
loops.  Such function is

\begin{small}
\begin{verbatim}
getAll(eObject, feature to collect, feature to follow, expected type)
\end{verbatim}
\end{small}

\noindent an invocation of \mytt{getAll} will return a list of ``expected
type'', built by collecting all the elements from ``feature to collect'' of the
specified ``eObject'', and recursively collecting such elements by following the
feature ``feature to collect'', but avoiding possible loops in the EMF graph
representing the AST.
Thus, in the use of Listing~\ref{lst:xsem-entitysubtyping}, it will return all
the superclasses of \mytt{right}.  Similarly, we can get all the attributes of
an entity, including the inherited ones, by simply calling

\begin{lstlisting}[language=xsemantics] 
	getAll(entity, 
		XsemGuiDslPackage::eINSTANCE.entity_Attribute,
		XsemGuiDslPackage::eINSTANCE.entity_SuperType,
		typeof(Attribute))
\end{lstlisting}

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-mostgeneral,caption=Rule
for \mytt{mostGeneral}.] 
rule MostGeneral
	G |- Type first ~~ Type second |> Type mostGeneral
from {
	{
		G |- first <~ second
		mostGeneral = first
	} or
		mostGeneral = second
}
\end{lstlisting}

The judgment \mytt{mostGeneral} (Listing~\ref{lst:xsem-judgments}) takes two
types as input parameters and returns as output the most general between the
two; this judgment has one simple rule, shown in
Listing~\ref{lst:xsem-mostgeneral}.

\begin{lstlisting}[language=xsemantics,float,label=lst:xsem-binaryexp,caption=Some
rules for binary expressions.] 
rule MinusType
	G |- Minus minus : NumberType type
from {
	// require number types
	G |- minus.left : var NumberType leftType
	G |- minus.right : var NumberType rightType
	// get the most general
	G |- leftType ~~ rightType |> type
}

rule PlusType
	G |- Plus plus : Type type
from {
	// deal with any type
	G |- plus.left : var Type leftType
	G |- plus.right : var Type rightType
	// get the most general (which can also be string)
	G |- leftType ~~ rightType |> type
}
\end{lstlisting}

The judgment \mytt{mostGeneral} is useful for typing some binary expressions,
for instance, \mytt{Minus} and \mytt{Plus}, shown in
Listing~\ref{lst:xsem-binaryexp}.  The typing rule for \mytt{Minus} requires
that the two subexpressions have a numeric type (recall that since we specify a
\mytt{NumberType} as the output argument in rule invocation, such invocation
will succeed only if the result is assignable to \mytt{NumberType}); the
resulting type will be the most general type, thus, for instance, if one of the
two subexpressions have type \mytt{FloatType} and the other one \mytt{IntType},
the resulting type will be \mytt{FloatType}.  Recall that we use \mytt{+} not
only as the arithmetic operator, but also for string concatenation; in
particular, if one of the subexpression is a string, the whole expression is
considered as string concatenation.  Thus, the rule for \mytt{Plus} computes the
types of the two subexpressions, and then gets the most general; if one of them
is a string type, the whole expression will have string type (see also subtyping
rules in Listing~\ref{lst:xsem-assignable}).

\subsection{Rules for the Validator}

In an Xsemantics we can specify some special rules which do not belong to any
judgment, \mytt{checkrule}, which are used by Xsemantics to generate a Java
validator for the Xtext language.  A \mytt{checkrule} has a name, a single
parameter (which is the EObject which will be checked by the validator) and the
premises (but no rule environment).  The syntax of the premises of a
\mytt{checkrule} is the same of standard rules.

\subsection{Usage in Xtext}

With the declarative specification (written in the Xsemantics DSL), Java methods are generated that can be used in the SopeProvider or Validators. 

If the declarative rules are marked with [â€¦], Xtext validator classes are directly created and no further work is necessary.

Example output for reusable methods

\begin{lstlisting}
TypeSystemResult<MyOtherGrammarElement> typeAsMyOtherGrammarElement(MyGrammarElement left); 
TypeSystemResult<MyGrammarElement, MyOtherGrammarElement> type(MyGrammarElement left, MyOtherGrammarElement right); 
TypeSystemResult<Boolean> checkType(MyGrammarElement left, MyOtherGrammarElement right); 
\end{lstlisting}
